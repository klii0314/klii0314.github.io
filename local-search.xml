<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GDOI2022退役记</title>
    <link href="/2022/04/06/GDOI2022%E9%80%80%E5%BD%B9%E8%AE%B0/"/>
    <url>/2022/04/06/GDOI2022%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>晚上跟随大部队来到考点附近的酒店，和 $AGC$ 分到了一间房，他还是那么的亲切。</p><p>传统艺能出去吃 $M$ 记，吃完回去 $AGC$ 教育了一下我，说考前不能吃东西，否则第二天会宝玲，我没试过，应该是假的。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>开考后看了看 $3$ 题题面，发现都没有想法，自知今天是 $div.1$ ，便开始想暴力。花了大概 $3h$ 将三题的暴力都写了，期望得分 $1+1+1=3$，想了想进队无望了，于是直接开摆。</p><p>最后 $10mins$ 突然发现 $3$ 题都是傻逼题！！1</p><p>我赶紧 $rush$ ，但是显然失败了，如果再给我一分钟我就能赛后一分钟切了。</p><p>出考场，身边的人都在吐槽傻逼题，但是都没调出来，导致暴力分都没。</p><p>我觉得还有救。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>昨晚摸太晚了，导致今天只睡了 $1h$ 不到，有点小困。</p><p>开题，发现三个傻逼题，怎么今天是普及场！！1</p><p>正序开题，仔细想想 $T1$，发现有点难写，可恶，《摆了摆了。》</p><p>然后发现 $T2,T3$ 都难写，为什么出这种勾巴题？？写了三个暴力就补觉去了，免得被 $d$ “怎么摆烂啊？”。</p><p>出考场发现题目又被喷力，好！！1</p><p>我还是太菜了。</p><h1 id="Day-n"><a href="#Day-n" class="headerlink" title="Day n"></a>Day n</h1><p>$ccf$ 出分了，实际得分 $1+1+1+99+99+99=300,\text{GD rk 114}$ ，不多不少，$\text{AFO}$。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1017G The Tree</title>
    <link href="/2022/03/17/CF1017G-The-Tree/"/>
    <url>/2022/03/17/CF1017G-The-Tree/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1017G">$\text{link}$</a></p><p>对于询问 $\text{3 x}$ ，若操作 $\text{1 y}$ 使得 $x$ 染上了黑色，那么满足 $y$ 是 $x$ 的祖先并且 $y\longrightarrow$ 路径上操作 $1$ 的个数 $\ge$ 路径上的总点数（包括 $x,y$）。</p><p>考虑给每个点附一个权值 $-1$ ，操作 $\text{1 x}$ 则对 $x$ 单点 $+1$，那么查询时只需要判断 $x\longrightarrow rt$ 的路径上的后缀和最大值是否 $\ge 0$ 即可判断颜色，如果没有操作 $2$ 就做完了。</p><p>对于操作 $\text{2 x}$ ，将 $x$ 子树的权值覆盖为 $-1$ 可以使得子树内的点到 $x$ 的后缀和最大值正确，但是可能 $x\longrightarrow rt$ 的后缀和最大值出错，这需要将 $x$ 单点减小 “$rt\longrightarrow x$ 的后缀和最大值 + 1” ，然后就做完了。</p><p>时间复杂度 $\mathrm{O(n\log ^2 n)}$ 。</p><p><del>久违的 1A</del></p><p>$\texttt{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<span class="hljs-type">int</span> n, q, s[maxn], fa[maxn], depth[maxn], son[maxn], top[maxn], tms, dfn[maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath)</span> </span>{    s[u] = <span class="hljs-number">1</span>; fa[u] = fath;    depth[u] = depth[fath] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) {        <span class="hljs-built_in">dfs1</span>(v, u);        s[u] += s[v];        <span class="hljs-keyword">if</span> (s[v] &gt; s[son[u]]) son[u] = v;    }}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> Top)</span> </span>{    top[u] = Top; dfn[u] = ++tms;    <span class="hljs-keyword">if</span> (!son[u]) <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">dfs2</span>(son[u], Top);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) <span class="hljs-keyword">if</span> (v ^ son[u]) <span class="hljs-built_in">dfs2</span>(v, v);}<span class="hljs-keyword">namespace</span> _Smt {    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> lson ls, l, mid</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rson rs, mid + 1, r</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> len, s, rx, tag;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag = <span class="hljs-number">1</span>; s = -len; rx = <span class="hljs-number">-1</span>;}    } t[maxn &lt;&lt; <span class="hljs-number">2</span>], ept;    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{        c.s = a.s + b.s;        c.rx = <span class="hljs-built_in">max</span>(b.rx, a.rx + b.s);        <span class="hljs-keyword">return</span> c;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{        t[u].len = r - l + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (l == r) {t[u].s = t[u].rx = <span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>;}        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(lson); <span class="hljs-built_in">build</span>(rson);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        <span class="hljs-keyword">if</span> (t[u].tag) {            t[ls].<span class="hljs-built_in">ladd</span>();            t[rs].<span class="hljs-built_in">ladd</span>();            t[u].tag = <span class="hljs-number">0</span>;        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (l == r) {t[u].s += y; t[u].rx += y; <span class="hljs-keyword">return</span>;}        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(lson, x, y);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf1</span>(rson, x, y);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(); <span class="hljs-keyword">return</span>;}        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(lson, x, y);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rson, x, y);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(lson, x, y);        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rson, x, y);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(lson, x, y), <span class="hljs-built_in">qry</span>(rson, x, y));    }    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        Node res = ept;        res.rx = <span class="hljs-number">-1e9</span>;        <span class="hljs-keyword">while</span> (top[u] ^ <span class="hljs-number">1</span>) {            res = <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[top[u]], dfn[u]), res);            u = fa[top[u]];        }        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, dfn[u]), res).rx;    }    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> lson</span>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rson</span>}<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;q);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {        <span class="hljs-type">int</span> u; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;u);        G[u].<span class="hljs-built_in">push_back</span>(i);    }    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">while</span> (q--) {        <span class="hljs-type">int</span> opt, x; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;opt, &amp;x);        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], <span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + s[x] - <span class="hljs-number">1</span>);            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], -<span class="hljs-built_in">ask</span>(x) - <span class="hljs-number">1</span>);        }        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-built_in">ask</span>(x) &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"black"</span> : <span class="hljs-string">"white"</span>);    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树链剖分</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫队二次离线学习笔记</title>
    <link href="/2022/03/17/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/17/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P4887">$\texttt{Luogu P4887 [模板]莫队二次离线}$</a></p><p>设莫队指针移动时间复杂度为 $O(k)$ ，则普通莫队的时间复杂度为 $O(m\sqrt n k)$ ，使用莫队二次离线可以变成 $O(m\sqrt n + nk)$ 。</p><p>本题直接莫队做是 $O(m\sqrt n\binom{14}{k})$ 的，无法通过。</p><p>记 $a_x$ 对区间 $[l,r]$ 的贡献为 $f(x,[l,r])$，<strong>差分</strong>后贡献记为 $f(x,r)-f(x,l-1)$，即 $f(x,r)$ 表示 $x$ 对前缀 $[1,r]$ 的贡献。考虑莫队指针移动过程中答案的变化：</p><ul><li><p>$[l,r]\longrightarrow [l,qr]:$</p><ul><li><p>$qr &gt; r:$ 答案增加 $\sum\limits_{i=r+1}^{qr}f(i,i-1)-f(i,l-1)$</p></li><li><p>$qr &lt; r:$ 答案减少 $\sum\limits_{i=qr+1}^r f(i,i-1) - f(i,l-1)$</p></li></ul></li><li><p>$[l,r]\longrightarrow [ql,r]:$</p><ul><li><p>$ql &lt; l:$ 答案增加 $\sum\limits_{i=ql}^{l-1} f(i,r)-f(i,i)$</p></li><li><p>$ql &gt; l:$ 答案减少 $\sum\limits_{i=l}^{ql-1} f(i,r)-f(i,i)$</p></li></ul></li></ul><p>$f(i,i)$ 和 $f(i,i-1)$ 都是固定的，可以预处理直接计算；</p><p>$f(i,l-1)$ 和 $f(i,r)$ 则使用扫描线解决，具体地说：</p><ul><li><p>对于每个前缀 $[1,i]$，开一个 $vector$ 存下所有的询问 $f([l,r],i)$，记 $g(x)$ 表示 $a_{[1,i]}$ 中 $\oplus x$ 的二进制表示下恰好有 $k$ 个 $1$ 的个数，则对于询问 $f([l,r],i)$ 的贡献即为 $\sum\limits_{i=l}^r g(a_i)$。</p></li><li><p>处理完 $[1,i]$ 然后处理 $[1,i+1]$ 时，枚举 $a_{i+1}$ 取反 $k$ 位更新 $g$ 即可。</p></li></ul><p>询问可以用四元组 $(l,r,id,1/-1)$ 表示询问 $f([l,r],i)$，询问编号 $id$ 以及增减 $1/-1$。</p><p>$\texttt{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> f ? -x : x;}<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, k, a[maxn], B;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {    <span class="hljs-type">int</span> l, r, id, pos;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> _ques &amp;a) <span class="hljs-type">const</span> {        <span class="hljs-keyword">return</span> pos ^ a.pos ? l &lt; a.l : pos &amp; <span class="hljs-number">1</span> ? r &gt; a.r : r &lt; a.r;    }} qr[maxn];<span class="hljs-type">long</span> <span class="hljs-type">long</span> sum[maxn], ans[maxn];<span class="hljs-type">int</span> f[maxn], g[maxn];vector&lt;<span class="hljs-type">int</span>&gt; trs;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">st</span> {    <span class="hljs-type">int</span> l, r, id, dt;    <span class="hljs-built_in">st</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> dt = <span class="hljs-number">0</span>) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">r</span>(r), <span class="hljs-built_in">id</span>(id), <span class="hljs-built_in">dt</span>(dt) {}};vector&lt;st&gt; vec[maxn];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();    B = <span class="hljs-built_in">sqrt</span>(n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {        <span class="hljs-type">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();        qr[i] = (_ques){l, r, i, l / B};    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>); S++) {        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++) cnt += S &gt;&gt; i &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (cnt == k) trs.<span class="hljs-built_in">pb</span>(S);    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {        f[i] = g[a[i]];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> S : trs) g[a[i] ^ S]++;    }    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(g));    <span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + m + <span class="hljs-number">1</span>);    <span class="hljs-type">int</span> l = qr[<span class="hljs-number">1</span>].l, r = qr[<span class="hljs-number">1</span>].r;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>; i &lt;= r; i++) sum[<span class="hljs-number">1</span>] += f[i];    <span class="hljs-keyword">if</span> (l &lt; r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(l + <span class="hljs-number">1</span>, r, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {        <span class="hljs-keyword">if</span> (r &lt; qr[i].r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(r + <span class="hljs-number">1</span>, qr[i].r, i, <span class="hljs-number">-1</span>));        <span class="hljs-keyword">if</span> (r &gt; qr[i].r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(qr[i].r + <span class="hljs-number">1</span>, r, i, <span class="hljs-number">1</span>));        <span class="hljs-keyword">while</span> (r &lt; qr[i].r) sum[i] += f[++r];        <span class="hljs-keyword">while</span> (r &gt; qr[i].r) sum[i] -= f[r--];        <span class="hljs-keyword">if</span> (l &gt; qr[i].l) vec[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(qr[i].l, l - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>));        <span class="hljs-keyword">if</span> (l &lt; qr[i].l) vec[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(l, qr[i].l - <span class="hljs-number">1</span>, i, <span class="hljs-number">-1</span>));        <span class="hljs-keyword">while</span> (l &gt; qr[i].l) sum[i] -= f[--l];        <span class="hljs-keyword">while</span> (l &lt; qr[i].l) sum[i] += f[l++];    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> S : trs) g[a[i] ^ S]++;        <span class="hljs-keyword">for</span> (st qry : vec[i]) {            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = qry.l; j &lt;= qry.r; j++) {                sum[qry.id] += qry.dt * g[a[j]];                <span class="hljs-keyword">if</span> (j &lt;= i &amp;&amp; k == <span class="hljs-number">0</span>) sum[qry.id] -= qry.dt;            }        }    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {        sum[i] += sum[i - <span class="hljs-number">1</span>];        ans[qr[i].id] = sum[i];    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ul><li><p><a href="https://www.luogu.com.cn/problem/P7906">$\text{[Ynoi2005] rpxleqxq}$</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P5047">$\text{[Ynoi2019 模拟赛] Yuno loves sqrt technology II}$</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P5501">$\text{[LnOI2019]来者不拒，去者不追}$</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P5398">$\text{[Ynoi2018] GOSICK}$</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>群论学习笔记</title>
    <link href="/2022/03/16/%E7%BE%A4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/16/%E7%BE%A4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料： <a href="https://www.luogu.com.cn/blog/command-block/qun-lun-xiao-ji">command_block’s blog</a></p></blockquote><h1 id="群的概念及基本性质"><a href="#群的概念及基本性质" class="headerlink" title="群的概念及基本性质"></a>群的概念及基本性质</h1><ul><li><p>由集合 $G\neq \emptyset$ 和 $G$ 上的二元运算 $*$ 组成。</p></li><li><p>满足以下性质：</p><ul><li><p>封闭性：$\forall a,b\in G,$ 均有 $(a*b)\in G$。</p></li><li><p>结合律：$(a*b)*c=a*(b*c)$ 。</p></li><li><p>存在单位元：存在 $\epsilon\in G$ 使得 $\forall a\in G$，均有 $a*\epsilon=\epsilon *a=a$ 。</p></li><li><p>存在逆元：$\forall a \in G,$ 均存在 $b\in G$ 使得 $a*b=\epsilon$。</p></li></ul></li><li><p>定理：单位元唯一。证明略去。</p></li><li><p>定理：每个元素的逆元唯一。证明略去。</p></li><li><p>定理：对于任意的有限群 $G={\epsilon,a_1,…,a_n}$，$\forall a\in G$，均存在一个常数 $b$ 使得 $a^b=\epsilon$，且有 $a^{-1}=a^{b-1}$ ，称 $b$ 为 $a$ 的阶。证明略去。</p></li></ul><h1 id="置换与置换群"><a href="#置换与置换群" class="headerlink" title="置换与置换群"></a>置换与置换群</h1><ul><li><p>置换的定义：有限集合到自身的双射称作置换。</p><p>  可以写作</p><p>  $$\large\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\end{pmatrix}$$</p></li><li><p>置换的乘法：相当于将映射叠加。</p><p>  性质：</p><ul><li><p>置换的乘积还是置换。</p></li><li><p>满足交换律。</p></li><li><p>单位元为 $\large\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\1&amp;2&amp;3&amp;…&amp;n\end{pmatrix}$</p></li><li><p>$\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\end{pmatrix}$ 的逆元为 $\begin{pmatrix}p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\\1&amp;2&amp;3&amp;…&amp;n\end{pmatrix}$</p></li></ul><p>  一般不满足交换律。</p></li><li><p>置换群：由上面的性质可知对 $1..n$ 作用的所有置换形成一个群。一般只研究一个子群。</p></li><li><p>置换的循环：把置换看作有向图，连边 $(i,p_i)$，会形成若干个环。</p><p>  置换可以用这些环来表示，并且是唯一的。</p></li></ul><h1 id="text-Burnside-引理-与-text-Polya-定理"><a href="#text-Burnside-引理-与-text-Polya-定理" class="headerlink" title="$\text{Burnside}$ 引理 与 $\text{Polya}$ 定理"></a>$\text{Burnside}$ 引理 与 $\text{Polya}$ 定理</h1><p>设 $G$ 为 $1..n$ 的一个置换群。</p><ul><li><p>不动点：对于 $p\in G$ ，若 $p_k = k$ 则称 $k$ 是 $p$ 下的不动点。</p><p>  $p$ 下的不动点个数记作 $c(p)$。</p></li><li><p>$\text{k}$ 不动置换类</p><p>  对于 $p\in G$，若 $k$ 是 $p$ 下的不动点，则称 $p$ 属于 $\text{k}$ 不动置换类，记作 $p\in Z_k$。$Z_k$ 为 $G$ 的一个子群。</p></li><li><p>等价类：等价类 $E_k$ 为对元素 $k$ 任意施加 $G$ 中的置换所能到达的元素集合。</p><ul><li>定理：当 $x,y$ 同属一个等价类时，有 $|Z_x| = |Z_y|$。证明略去。</li></ul></li><li><p>轨道-稳定子定理：</p><p>  $$|Z_k|\times|E_k|=G$$</p><p>  证明略去。</p></li><li><p>$\text{Burnside 引理}$ ：</p><p>  记 $l$ 为 $E_{1..n}$ 中本质不同的等价类个数，则有： </p><p>  $$l = \large\dfrac 1 {|G|}\sum\limits_{p\in G}c(p)$$</p><p>  即等价类个数 $=$ 所有置换下的不动点总数的平均数。</p></li><li><p>$\text{Polya 定理}$:</p><p>  设有 $n$ 个元素，每个元素有 $m$ 种染色方案。</p><p>  设 $G$ 是 $n$ 个元素的置换群，则染色总方案数为：</p><p>  $$\large\dfrac 1 {|G|}\sum\limits_{p\in G}T(p)$$</p><p>  其中 $T(p)$ 表示在置换 $p$ 下不动的染色方案数。</p></li></ul><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p><a href="https://www.luogu.com.cn/problem/P4980">$\text{[模板]Polya 定理}$</a></p><p><a href="https://www.luogu.com.cn/problem/P4916">$\text{[MtOI2018]魔力环}$</a></p><p><a href="https://www.luogu.com.cn/problem/P4727">$\text{[HNOI2009]图的同构计数}$</a></p><p><a href="https://www.luogu.com.cn/problem/P4128">$\text{[SHOI2006] 有色图}$</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CF1109F Sasha and Algorithm of Silence&#39;s Sounds</title>
    <link href="/2022/03/16/CF1109F-Sasha-and-Algorithm-of-Silence-s-Sounds/"/>
    <url>/2022/03/16/CF1109F-Sasha-and-Algorithm-of-Silence-s-Sounds/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1109F">$\text{link}$</a></p><p>首先考虑计算每个左端点对应的合法右端点的个数，可以发现随着 $l$ 的增大，使得 $[l,r]$ 不存在环的最大的 $r$ 是单调递增的，然后我就不会了。。。</p><p>看了题解才想起来可以利用树“点数-边数=1”的性质计算，于是拿棵线段树顺便维护一下“点数-边数”的最小值以及最小值的个数就好了，因为 $[l,l]$ 显然满足 “点数-边数=1” 。</p><p>时间复杂度 $\mathrm{O(nm\log(nm))}$ 。</p><p>这种性质还是要想的起来啊。</p><p>线段树四倍空间 /fn/fn/fn</p><p>$\text{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, nm, a[maxn][maxn];vector&lt;<span class="hljs-type">int</span>&gt; G[maxm];<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<span class="hljs-keyword">namespace</span> LCT {    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>], fa, tag;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clr</span><span class="hljs-params">()</span> </span>{ch[<span class="hljs-number">0</span>] = ch[<span class="hljs-number">1</span>] = fa = tag = <span class="hljs-number">0</span>;}        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag ^= <span class="hljs-number">1</span>; <span class="hljs-built_in">swap</span>(ch[<span class="hljs-number">0</span>], ch[<span class="hljs-number">1</span>]);}    } t[maxm];    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">nrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">return</span> t[t[x].fa].ch[<span class="hljs-number">0</span>] == x || t[t[x].fa].ch[<span class="hljs-number">1</span>] == x;}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y)) t[z].ch[t[z].ch[<span class="hljs-number">1</span>] == y] = x;        t[t[y].fa = x].fa = z;        <span class="hljs-type">int</span> gx = t[y].ch[<span class="hljs-number">1</span>] == x;        t[y].ch[gx] = t[x].ch[gx ^ <span class="hljs-number">1</span>];        t[t[x].ch[gx ^ <span class="hljs-number">1</span>]].fa = y;        t[x].ch[gx ^ <span class="hljs-number">1</span>] = y;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-keyword">if</span> (t[x].tag) {            t[t[x].ch[<span class="hljs-number">0</span>]].<span class="hljs-built_in">ladd</span>();            t[t[x].ch[<span class="hljs-number">1</span>]].<span class="hljs-built_in">ladd</span>();            t[x].tag = <span class="hljs-number">0</span>;        }    }    <span class="hljs-type">int</span> stk[maxm], top;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-type">int</span> u = x;        <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">nrt</span>(u); u = t[u].fa) stk[++top] = u;        <span class="hljs-built_in">pd</span>(u); <span class="hljs-keyword">while</span> (top) <span class="hljs-built_in">pd</span>(stk[top--]);        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nrt</span>(x)) {            <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y) &amp;&amp; ((t[z].ch[<span class="hljs-number">0</span>] == y) == (t[y].ch[<span class="hljs-number">0</span>] == x))) <span class="hljs-built_in">rotate</span>(y);            <span class="hljs-built_in">rotate</span>(x);        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; x; y = x, x = t[x].fa) <span class="hljs-built_in">splay</span>(x), t[x].ch[<span class="hljs-number">1</span>] = y;}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x); t[x].<span class="hljs-built_in">ladd</span>();}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">mrt</span>(x); <span class="hljs-built_in">access</span>(y); <span class="hljs-built_in">splay</span>(y);}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">split</span>(x, y); t[x].fa = t[y].ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;}    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">frt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x);        <span class="hljs-keyword">while</span> (t[x].ch[<span class="hljs-number">0</span>]) <span class="hljs-built_in">pd</span>(x), x = t[x].ch[<span class="hljs-number">0</span>];        <span class="hljs-built_in">splay</span>(x); <span class="hljs-keyword">return</span> x;    }    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-built_in">mrt</span>(x);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">frt</span>(y) == x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        t[x].fa = y; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }}<span class="hljs-keyword">namespace</span> _Smt {    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> mn, sz, tag;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{mn += x; tag += x;}    } t[maxm &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{        <span class="hljs-keyword">if</span> (a.mn &lt; b.mn) c.mn = a.mn, c.sz = a.sz;        <span class="hljs-keyword">if</span> (a.mn &gt; b.mn) c.mn = b.mn, c.sz = b.sz;        <span class="hljs-keyword">if</span> (a.mn == b.mn) c.mn = a.mn, c.sz = a.sz + b.sz;        <span class="hljs-keyword">return</span> c;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        <span class="hljs-keyword">if</span> (t[u].tag) {            t[ls].<span class="hljs-built_in">ladd</span>(t[u].tag);            t[rs].<span class="hljs-built_in">ladd</span>(t[u].tag);            t[u].tag = <span class="hljs-number">0</span>;        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (l == r) {t[u] = (Node){y, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}; <span class="hljs-keyword">return</span>;}        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf</span>(ls, l, mid, x, y);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(z); <span class="hljs-keyword">return</span>;}        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>((Node){<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, <span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));    }    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>}<span class="hljs-type">int</span> lx;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lk</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> x)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++) {        <span class="hljs-type">int</span> v = G[x][i];        <span class="hljs-keyword">if</span> (v &lt; l || v &gt; x) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (!LCT::<span class="hljs-built_in">link</span>(x, v)) {            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {                <span class="hljs-keyword">if</span> (G[x][j] &lt; l || G[x][j] &gt; x) <span class="hljs-keyword">continue</span>;                LCT::<span class="hljs-built_in">cut</span>(x, G[x][j]);            }            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        lx++;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-type">int</span> dt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> r)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[x]) {        <span class="hljs-keyword">if</span> (v &gt; r || v &lt; x) <span class="hljs-keyword">continue</span>;        LCT::<span class="hljs-built_in">cut</span>(x, v);        <span class="hljs-comment">// printf("? %d %d %d\n", x, v, r);</span>        _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, v, r, <span class="hljs-number">1</span>);    }}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> r = <span class="hljs-number">2</span>;    _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt; nm; l++) {        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>        <span class="hljs-keyword">while</span> (r &lt;= nm) {            lx = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">lk</span>(l, r)) <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// printf("%d %d %d\n", r, qry2(1, 1, nm, r - 1), lx);</span>            _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r, _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r - <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>).mn + <span class="hljs-number">1</span> - lx);            r++;        }        ans += _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l, r - <span class="hljs-number">1</span>).sz;        <span class="hljs-comment">// printf("%d %d %d %d\n", l, r - 1, _Smt::qry(1, 1, nm, l, r - 1).mn, _Smt::qry(1, 1, nm, l, r - 1).sz);</span>        <span class="hljs-comment">// for (int i = l; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>        <span class="hljs-built_in">ct</span>(l, r - <span class="hljs-number">1</span>); _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);        <span class="hljs-comment">// puts("?");</span>        <span class="hljs-comment">// for (int i = l + 1; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>    }    ans++;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m); nm = n * m;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i][j]);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i - <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j - <span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span> (i &lt; n) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i + <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">if</span> (j &lt; m) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j + <span class="hljs-number">1</span>]);    }    <span class="hljs-built_in">solve</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>LCT</tag>
      
      <tag>Two Pointers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CF232E Quick Tortoise</title>
    <link href="/2022/03/15/CF232E-Quick-Tortoise/"/>
    <url>/2022/03/15/CF232E-Quick-Tortoise/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF232E">$\text{link}$</a></p><p>先将询问离线下来分治，设当前分治区间为 $[l,r]$ , $mid = (l + r) &gt;&gt; 1$，考虑处理左上角到右下角的询问，剩下的分到左右两边。</p><p>由于路径必然经过 $y=mid$ 这条直线，考虑记 $g1(i,j,k) = 1/0$ 表示 $(i,j)$ 能否走到 $(k,mid)$， $g2(i,j,k) = 1/0$ 表示 $(k,mid)$ 能否走到 $(i,j)$，</p><p>然后转移用 $bitset$ 优化一下就可以做到 $\mathrm{O(\dfrac {n^2m\log m}{\omega} + \dfrac {qn}{\omega})}$ 。</p><p>实现的时候 $(i,j)$ 的意义是反过来的（（</p><p>$\text{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> f ? -x : x;}<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">500</span> + <span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxq = <span class="hljs-number">6e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans[maxq]; <span class="hljs-type">char</span> c[maxn][maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {    <span class="hljs-type">int</span> xl, yl, xr, yr, id;} qr[maxq], q0[maxq], q1[maxq];<span class="hljs-type">int</span> ck[maxn];bitset&lt;maxn&gt; g1[maxn][maxn], g2[maxn][maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>{    <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (l == r) {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ck[i] = ck[i - <span class="hljs-number">1</span>] + (c[i][r] == <span class="hljs-string">'#'</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)        <span class="hljs-keyword">if</span> (ck[qr[i].xr] == ck[qr[i].xl - <span class="hljs-number">1</span>]) ans[qr[i].id] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span>;    }    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, c0 = <span class="hljs-number">0</span>, c1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) g1[j][i].<span class="hljs-built_in">reset</span>(), g2[j][i].<span class="hljs-built_in">reset</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {            <span class="hljs-keyword">if</span> (i) g2[mid][i] |= g2[mid][i - <span class="hljs-number">1</span>];            g2[mid][i].<span class="hljs-built_in">set</span>(i);        }        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &lt;= r; j++) {            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (i) g2[j][i] |= g2[j][i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (j &gt; mid) g2[j][i] |= g2[j - <span class="hljs-number">1</span>][i];        }    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) {        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {            <span class="hljs-keyword">if</span> (i &lt; n) g1[mid][i] |= g1[mid][i + <span class="hljs-number">1</span>];            g1[mid][i].<span class="hljs-built_in">set</span>(i);        }        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &gt;= l; j--) {            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (i &lt; n) g1[j][i] |= g1[j][i + <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (j &lt; mid) g1[j][i] |= g1[j + <span class="hljs-number">1</span>][i];        }    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)    <span class="hljs-keyword">if</span> (qr[i].yr &lt;= mid) q0[++c0] = qr[i];    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qr[i].yl &gt; mid) q1[++c1] = qr[i];    <span class="hljs-keyword">else</span> {        <span class="hljs-comment">// printf("%d %d %d\n", qr[i].id, g1[qr[i].yl][qr[i].xl].count(), g2[qr[i].yr][qr[i].xr].count());</span>        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g1[qr[i].yl][qr[i].xl][j] ? 1 : 0); puts("");</span>        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g2[qr[i].yr][qr[i].xr][j] ? 1 : 0); puts("");</span>        <span class="hljs-keyword">if</span> ((g1[qr[i].yl][qr[i].xl] &amp; g2[qr[i].yr][qr[i].xr]).<span class="hljs-built_in">count</span>()) ans[qr[i].id] = <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c0; i++) qr[L + i - <span class="hljs-number">1</span>] = q0[i];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c1; i++) qr[R - i + <span class="hljs-number">1</span>] = q1[i];    <span class="hljs-built_in">solve</span>(l, mid, L, L + c0 - <span class="hljs-number">1</span>);    <span class="hljs-built_in">solve</span>(mid + <span class="hljs-number">1</span>, r, R - c1 + <span class="hljs-number">1</span>, R);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, c[i] + <span class="hljs-number">1</span>);    <span class="hljs-type">int</span> q = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) {        <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();        qr[i].xl = x; qr[i].yl = y;        x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();        qr[i].xr = x; qr[i].yr = y;        qr[i].id = i;    }    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, q);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) <span class="hljs-built_in">puts</span>(ans[i] ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>bitset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「雅礼集训 2018 Day7」A</title>
    <link href="/2022/03/15/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day7%E3%80%8DA/"/>
    <url>/2022/03/15/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day7%E3%80%8DA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/p/6507">$\text{link}$</a></p><p>用线段树维护 $\text{And,Or,Min}$ 值，对于操作：</p><ul><li><p>$\text{And x}$，设当前点为 $u$，区间值分别为 $ta(u),to(u),tm(u)$：</p><ul><li><p>若 $x \And to(u) = to(u)$ ,则该操作对当前区间 $[l(u),r(u)]$ 的值无效；</p></li><li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p></li><li><p>否则直接暴力递归下去。</p></li></ul></li><li><p>$\text{Or x}$，类似的有：</p><ul><li><p>若 $ta(u) \And x = x$ ,则该操作对当前区间无效；</p></li><li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p></li><li><p>否则直接暴力递归下去。</p></li></ul></li></ul><p>分析一下时间复杂度：每次暴力递归下去都会使得当前区间内所有数的某一位相同，每个区间不同位的总数为 $\mathrm{O(n\log n\log 值域)}$，时间复杂度即为 $\mathrm{O(n\log n\log 值域)}$ 。</p><p>$\text{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> f ? -x : x;}<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, q, a[maxn];<span class="hljs-keyword">namespace</span> _Smt {    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> a, o, m, tg1, tg2;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a &amp;= x; o &amp;= x; m &amp;= x; tg1 = ~tg1 ? tg1 &amp; x : x; tg2 &amp;= x;}        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a |= x; o |= x; m |= x; tg2 |= x; tg1 = ~tg1 ? tg1 ^ (tg1 &amp; x) : tg1;}    } t[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        t[u].a = t[ls].a &amp; t[rs].a;        t[u].o = t[ls].o | t[rs].o;        t[u].m = <span class="hljs-built_in">min</span>(t[ls].m, t[rs].m);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        <span class="hljs-keyword">if</span> (~t[u].tg1) t[ls].<span class="hljs-built_in">aladd</span>(t[u].tg1), t[rs].<span class="hljs-built_in">aladd</span>(t[u].tg1);        <span class="hljs-keyword">if</span> (t[u].tg2) t[ls].<span class="hljs-built_in">oladd</span>(t[u].tg2), t[rs].<span class="hljs-built_in">oladd</span>(t[u].tg2);        t[u].tg1 = <span class="hljs-number">-1</span>; t[u].tg2 = <span class="hljs-number">0</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{        t[u].tg1 = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span> (l == r) {            t[u].a = t[u].o = t[u].m = a[l];            <span class="hljs-keyword">return</span>;        }        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, mid);        <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);        <span class="hljs-built_in">up</span>(u);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{        <span class="hljs-keyword">if</span> ((z &amp; t[u].o) == t[u].o) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {            <span class="hljs-keyword">if</span> (l == r) {                t[u].<span class="hljs-built_in">aladd</span>(z);                <span class="hljs-keyword">return</span>;            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {                t[u].<span class="hljs-built_in">aladd</span>(z);                <span class="hljs-keyword">return</span>;            }        }        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(ls, l, mid, x, y, z);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf1</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);        <span class="hljs-built_in">up</span>(u);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{        <span class="hljs-keyword">if</span> ((t[u].a &amp; z) == z) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {            <span class="hljs-keyword">if</span> (l == r) {                t[u].<span class="hljs-built_in">oladd</span>(z);                <span class="hljs-keyword">return</span>;            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {                t[u].<span class="hljs-built_in">oladd</span>(z);                <span class="hljs-keyword">return</span>;            }        }        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);        <span class="hljs-built_in">up</span>(u);    }    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u].m;        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));    }}<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">while</span> (q--) {        <span class="hljs-type">int</span> opt, l, r, x;        opt = <span class="hljs-built_in">read</span>(); l = <span class="hljs-built_in">read</span>(); r = <span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) {            x = <span class="hljs-built_in">read</span>();            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);        }        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {            x = <span class="hljs-built_in">read</span>();            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);        }        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r));        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>势能分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>联合省选2022前的记录</title>
    <link href="/2022/03/11/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892022%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/11/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892022%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="79e3d05c00557af9f21a26161ef470d3571b876e2af2961c356f8eda6f70dfda">cd67862bdd141bb2aa1c78ab2fd399f67a60072de8008dd25d832ed6a25ec958c271597d94c64ba64b861d786834b124f3413b301a1947fc82287715bebaf983742e692ce9848f3d0d1dfab8866ef2606fc28aac7911ddecd98658ecd7421ff77c084239223d3a9f7902c42305103a7e25b8ab892265bf88192ab7a471c22cdee0dfa3b1b5c4c7cca0a7148e905c01811f03e0893d457b913f834c4bf9af4657308375adac2a0e7d2a8842c81cdad5c45859e47ff9902835be56befbe3ba53bfb9c0d5991954fa5a1a29539b43004413df1e5ebbcbf7e7fe9eba30137fb6798a66fcdf4f55b1fd3510b5bfefca8a81ad434a42e043b9b0ef545cafb8ef066728f33b942f0b6c60d8329db36ae4ad4699b271dc46f3c75dc6655411af98995a21146067465c8fae9f54fce26608d7a6f836ffadafd2a8c838569849e56fc83cb589641b3fc21810b9bff2ba385b982b7a41b1763a877e55952494aad806fb5b4f7e98b98c031998758a67ddfcfe1b29fee0b0c5826d0c74f7de0cdb9dbaf960c19aca2a93b37f670864281d075139a33df13b62819039f397f0617cda4b7bfe62596fdfb9aa0e46a35a4639c04eb8ff1c6ff02a5fcd9e7fc29fb3097f2daedc1c92082c1151f3c8f7381930e771e2a46651686b04185a86ec8564bc8357273d46ea322a0045d8627854353bfeb969b0e14a0df08ee1314fd9bdea82d9307b7c2816a3d97544b8ebc0c23dac4390005767552eabec4541f6506ebf58aef1f127c1d822a4e2565097e0f100b32e2b8a7a5007590d73d53ed4ab5bbe69727d91ae7d4aa5c781c05bb9b0ea0a6274351877e0b41b7f3702935c7fea3025d6e11b991986c145143932125d45c857fd79cd9d5cb758ff54a3275798e10dd38b4fd15d10702660f28d34a9b9bc5c42fb9307ce9f918b75dc9e2c9cb649376afd2c7f6b2bdcc5f34e329b48bc843e37a8d27a3c9f82f2686a9b13fb29763b11953610b7a7895728128ce35abb253075ebf590302d9927e469ca1e67645670a9f3b42fbaa087e5b324658fbf997c5e70982d388b18d67db4517c482262bcecafa19e6a692861032951f54fa5db44d241487bbe05a5d54e512fd7bc9de95fcce624eab34d0efc53c5e19dbeb3213518ad8a359f12f35c2868e4afc64e2edaef5f0ade555cf453f304c18938280e7a823fdad37737c014cbbd665c94060312845bbf3631769d1c1e4ebe840e6722170df2ad486bca86f27ad1a6407abce8ee7b71eacc74d1f29dbf154c4caf9d0e4b88c963d119c2f3bce478059632d08688f42b5cacf18ef3c54cbe42fcf927a0ea353dbb938eca855a5599496618f0d100e5603e004b03299ac1b643f6e7e6a09bbc5a5683d1566f298857349b8063bb4837771e1e8b7de38f0335090e8791a42177f13c85ee1d59036f478cbf85f2e5e939cf80f4bdc9b859f06c6de22b5c25ead17349814eb854e22d3b64daf10aaecf4b85cb01edce92c9b5c336edef55ead6592e2b4b34b35700dd57d4e352045ef8d667f7651e3ebd9260349778df80bf08555c75bb85ca249ec764e45de6db63a56e7f264a92e67f7ad27b179831d7bd6dcb4bddc2d72aec41675cc102045670ff945f8bbd40df696a210e1cf7a481dd49085c56fae452d70e1f72c341dc3e4cb124c0534c7afcb8894f6124a68ede512805fc5f51ce293d3da2d5e8ce603023a9f3780ef96b51c7e87b43516939ded784a3b5f52acf8f98a54beeadc82d8ce5589ba3bdd67e16bc6d00d6af80f7645a09931d0e246469da67f8f7b57f88512b780fa5f62fbafbdfe9c5d7f5555b02291d4d1be56ae83a89f6129ff39ab7aa3c9d58a0ed00f81228190a03fd396b397277a44c4c851114433428287cffabbe75f70c9ae699cb10d0286ad0fa5f81d9312405a10fccb9935fa11ba542914a6fcc50ef03e363b7dfde4f10919a5dd34cda844792da2065a0e223783dd599c5c33c6505d68c3f964bc8d083fbf40d9378a5964b00115a97ea202822e2fd0e48605b679b8a58e03b9c363e7e9754491250daa579e5ad7fcdb6d09560043c3723ba30ee171c634c6e41e8523f0f60fa8033ee0412b890224913103dc1404d6585ff9603bb5183ffa6f11640de1736cfd27133408dc51a29dbd1f09a68895f570acd25615ba848d927f3a46105b4787527ee0eccf2d5c38ed3f776671f280624ad0c65124125585f2d2a02e17925d3c023c96be5cbd62a4e00e4a5514fa319ad6f236a9e133744e32429bb32f71b921d3885d1d1a82295fd445cca16502c6c8d5c6bccdc2426ad08ac27d5dc0d2c833c0f823460e1bf6d77adb5545c58ae082e082176955ea2db2734296bad2f659859892dcf3f57e5136ed4a26d2979dc2f1f4d2ea056647042178e63307655469022cfd66ec3e82354f62559886435a5f70c259d1c1cff059e98b003cbf123a6c58f724ac102ec9df836e16919d80fac82d375331d0e55ab95f83b0f9a3085291b5714ad434738d6ecfdd3f3d5bf483e955a366c18812aac1e20a3531350762c9f269f43ae185c7c37a7eab85b60dc00d690ca463dc4bc535dda2fe6a653932e2488f8deb6c0c42509dd3a39be69e4a39796de680d8b1e8ad18ceda603794b9b75c5dfebb8ed9a0e828104f25b4322913848bc36655b2b6dfbf9cd6a9cb1da5990a89534a6da73685cb7faf5b90725608836fe034f1a2ef86e8a4b0c87c97fa4b7d1804a665bd7262942011d0d3a93017df44855f08c57a762e724648151f9944529384f814451e26e3e52e05360de7acf923b78ffaff4450da97b961c824e7de6ff035aa173b2c5ada9a8eabc0c9f8570b3cee1fda8dc67923d4948dbae091e153d2738c1cae3a810e3d8c8eca28f803b315b7687091646bc161463714c4ac40b24c837e39b7a4c716fab11212945c1b3587358a2cc91159d737fbeb83c0229ef12d658195ded65fc617f9961c10307e53707813ddc08c0d73d42ce10f978764f6e3ed8eb9ca256abc0a5c74e83542405f6606dda34edefb6b9d3206cc89e848c3c5d7c7443cb6c9c381116544d53b9a3e43c5665962fab599cfa8a9a1b61fd285a6cc7169c0d92cbf8d390999a01799554e1e9ac1a29c97d81d7f2d2fb3b3b15a24deda6b3f108c244a693e7e25b7ca4dfe99fad351a9a6af4d91755ff2eadb36cccf62591786b0dcb1e97781726d49f1bbc3ee8e8df99ca0074091af6ca76da531d380028b71aacfa28174c0ada938019de17d3d537a850a04af61afc4ace201beff8ec632d50db5fe386435da61d4ddd81adf46671e3d348b0c9f2e19c988a0797bf37d127b51bd8505beac06593889f4d35f28a1b576bcc3ef3d052f8b6cdb1212a5b7842d6b70421340d7fe9bb704125918e6156d43df199b85ffcf39b7fe55cf84e79592e49c49ce1ae3bab116c1d90a249d69e8564ff454472367470b88ade262fac8178331a7c4a9fbf5275ac698b48ae658356cb982fb81ceb40fc14db57907072911c3ef9e54af2f1639955082e3bfb51eb452d686a5c55008367a5130f2cb4072064055810222ac5aaebe8af3a575255f778fd4041d48272e51e6fe393c729862f8d6c78315cb9833986f27e9d7be9a39bad1e6b26b3aae4226382ee836477d19f09e7cc45e0ea77cefc4f12f39e0737467353f29f3e0167189b8b9d2577b25fe9f42091448a160ebb86267b103b8d40f4d134689017ef7387965f9fa06ecba67949b0513b4647f0bd8abfb7230b51df8312a4d6f910a1166507d30e5e776e3180b9eb0f0ccc81745ac729cba9a6da2b79965036ddf4848dd2985ef86101ea2b8229bdd1d0b55b93b6ca4f49d2831ae03dd3f5029ff69b14ca4a21b42973baa2aaf3a20e1a1d09e859058961405301661b886e4c058bf7d9181ca0827263b2d32a8759e0440267393bc7355140772fb7d20c3fab464aebac4117c69e7299120ede1300b97ee627ad8f97e13a1592ed6dfc03221a37a0a6c734f3cacade92fbf692e9ebf328a86cb15289f4c76a9b3b8660a6ddd534f5d6546f1c8db4e27973be1f3d48459eab96f8f1590708d0855d10ac679a5b7bac39fb0cda938c1e9e472dd0701e7cdf0913240345610b1bf154a8ac8908d42a57f9d404725ea500f7f531fbc211a3b671129aabd4b2c1bf31a2c3ad30ccd844b19e052c210a3f7603d5cc42199a43ade227b5c730983a914c1e9dd6a63e9badb0f9e5e09fb64a749ea5456f4ab97a2201037de79aa5844db44ca60ce1df925d042aabf2072b85d9f3a8d588ff68fd919417858071a5b61bab720990545fb097e3230b025e3708ce8203656d4fb661a7b8fc5024fdbe48e6672164886f20d283352612ab2b84b48e57d612dbdca8ba3e4e54d00ab6d265b7a5b7649154309d02d6f9e3a2004d402b5f0e3b37ce36a0c6e9db368b5a77d0876f84791339761e657407e4a0ffba7d36cf9dc7c02414b34c3477d3305886c99361dc012d450f530329882d307f48de6c9d1563d5e58ee26de2b4ca1de7aee0998e0475b7d6b7b4361fbca0c1a651b333b28d84c3db93e74fe5a558f2b0efca443993c18fd7fd0fd0feacfd342afae9421e90424f743bd833260fc3a197f42d556bc4bb9bec1719a0cf5947477801e361fcdacbc7fa6ac708fb5c16cbfed06f808072bcffd6ff707eb13ee6496c8836de4a5626cbcf06f8a684cc57c60fc6a3dbcd96c825ea9b774ab9d60e87305c2f1c5e5f2c4a521f678189420622fd889e87969b48f6a8c5a548356bbf429b6f6eca8f4a50ae4f3d70d0361a0bc3143c55047a3405107334d676763eaa08bbddd4dfe3351ac8f16874f2f9669b9a87ad5f185084dc19b0d530a275e9ee769abe11faca071231b731d682fd9cc6008d0b06d44c51402c6fb2fba837d2813740d98ab4e4191debb21615a9d090e42bf2a633e4d7168a9a487764fe639d5e0d53aff93269d0fc636e1283f43f0a254d6362bc0fd95d97c5be906bf0901de3d79f31d1894a884d1a19b2e898ffb1759a75db15ac7308f5685eb902e47060ccb1278a4b2935865a7572629844da4391c84abf1f7791ceab61bd06676c5e13d7e68806072bd0e5a0ee716c1192f1baaa7a699a14d4652e06f00a517b3ccedeea67f9ce7abf4caef7ed7655bbedfcbbbafa0c935145b6ebc7e17a9013885a969d55e1f0c9709ad8787571d70089267256c2622d1287a9bb834e10132507c5b33c1f68ff49cce448afa943ae2c21fa982a45e3c12f6950da3436b40d2bfe58c94e02ac6db84f4a50c5f30c8a9a533f62ab34023da9740c61d382aae63d26d1baa722480e4b001c0b935aabbbb19271cdade981b47ed6d3b71ff53fa2e656def0da9e40cfc68703c5dbfd4e19da67cbb38f5d09e7817a98f2a9a2b99a7d3674354e02fd37d69a60f70810793bd819ccae3e7ddb605374b5141edc248d221eb78c49d550f3b855522957618234070bafd7df2674b69599bfc565d6bc1de73a6b6a13d0352fb8c862cbfeacefd944ecaa30e29b5da2926289252054cf13e3fed0183875ccc38a27ebadd6ab82fcbefc814051c09b7b47ee67bf9babef89e43a939f95d0bf2bc10b7a7253ea4ea042beabcd4f860f5f93d5803f842a9758ab84aff8db2ac1dcef2d85def31b442effd363f5846d3cc4340759889723e4132f0aba58e7fd2f7308180819e9e7c22d777bd4c6ba20b295a449de842ef9de7d17b839dd9d7d392e3083e5ee3e4069b997dc72faa774dc90a24225e2262bf8a3b9d5a9bc19074ea96c6273da15fd9dae4a8ab8e81d6706734885aac0fb79cb1728013ab9c37edb52c2eed88a8aeb4db2650febe9c8541075c624c1912d26f19d83dc7eb20e19d1c5189d068dd69e5d50a8243b026400ffc263f1ce564eb50a85f0046f66d164422b6c05de3df25365b1802a55445ab5efd5e6bb7dcd1c51a7db1b87ffff2260a5d9c8447a08d894cfcef40e57f8af2ff1f8f9f0f9f508e51b8b3c6a6b1c2cb81e2f4e917e5ab858172da395c079041368780b8b8fa29978700294b3dcf64ed252f91593cb8e2dd54490aef58eff2fb9d0424f2cdb7c4afac7a5f7792769e3880163581f8b56405641448be49d57ed1dd9131bfe224e37949ba16c99e0815c51362a82694e3d2f531f16d77ba7b72457b9e54acc81003dd28e3621870fa29478d8af4507cd2b7c35cfe711135263c31ef3ee117d283666e959dd3c54fa319b8ee1ba99633b0232fbd55f94cdd1b64d882cb2d3e44b6d22803ffd17ac277776f7e51b2b4fa490a84190d282335f646758a2217a36401530a3464991a15405ac84f55c766d4591793caef7d3947e68084c80daddc11e7e80c156180a507868e0fbb713d77bce4c999a13974e692cefc40b24377da4369a8aa0d93d5601effe6e269628e25b9485106ba3145291c4062920ac8dd9375aed3a5e1bda37f61437f144a04e9a398cf271e6a046d9684de8663afbda26e1714986ae07f70301c09606c6c9862a0e1152602e7cafba8ac50410f30dde15285a1e6f166aceabfd6cf455d94d16bfb1b0304cf3d99167f0a8a7e05c257bb6f9ec8bddbc8a3d73fa8edfc90d8d16c1e9404b4a93128e4eb21b41bcfceed876540d218d979a32917d242de7c854c45575e7e2d90c63a0a6324294d59fadebf8481d2a46e9fed07c6ebb252bf77fad2ce42c7b15dabd7a6e96914bd7b12061e8115534966fafc925641b844aa0774149e78f64972b03da569c647347c35efb32dea7fd3eb1d465040aace6e2dce002fc6073da8b72644d775c851f99a0a85c356e748f329e6d5837c2f32324bbde35a2937c6db227539da9dd5b455ca1f1b2f4ac7ccb065b329e621dfb5d6f237edfef712963025a1494f75f1cf206b66b7de8b5781d50863ed735a62b899078a7c06fd8cfd8670328c70306bacac1b8946964d1944e1ab0b62b56c11dfdd064c8afb4f1136d7ad97c6116aab569d3763bbec58ea00a5197d6bf00a8143c1a30dc8c770a1a6a29912b67833749c68e903cbc6aaddf8ccf53232feb4291a0694a062995c3ec7dca0fee2bbfa801e5165242c3f48b2a9633fb503bba0402696f251883191b8aeb0a2c7071155ae4a5aeae56b71888b190e4f1e015514e8c86d8a920f77518cf08ca0609c822a806eb38880ed5d2082ddebb9fcfac4725a90f2d8a9930aa40bb358f0f0ddab5dee4e251337a4f0cd8f4d21e6d91e8dd28963a99a8bcdc84febc205c9487855c255db1f1756da9369c43b18509eb08858c8b53132a3fe0cb45cedfd2bd8200d81b3049da224016a968cb01eaad51d5764c236ded1ddf21c6662ce0dff3453f7bf7052ed9ad97b69c2b8ed3ebf75213f76c5d5ef3a91d3d45020a04d16d4cae3a0f769520f8509f0ab685b0a9514148213ad4f8c0c343b140ff1df99d27c30f9d6ebf136fe710004660c139b2d3ad3f215629ca9cdb36c7d3cd8906e0be441f1bf3578c5216eb6e45fd6648984a8071407cba1de6481f2e9ae29175c2cf2194651916e6649044956de3f1381f74123a54813d7c59b35b70af458834c0e070c9f353f4483595f76e10d0f138fe3668dfcf1a02f207fe355228bda62a3080a59f6ee0d9f54021480b9d835799c4e390982067f1748ee7c86d8bf6f5e7eeb4690f394998da7c2d8c683c2cbe5893c73948db9dcbc4cf9d0ab344e3e9d3a1169e49815a179c38e24da04b2ffb331514c220e3efa9358f499087b8106904500d9485cc39107b0760130b9d0d4ea4b348e9d8e8fc3b73c3ade51d3d5d438dc259010bea664cfbc0f88d7203c94d9370ddf6b753ae6bcd96f6e68046b3e16ed5faed13e41f0246c8b362a9b615b67213d74fc71c09b3f802e809162a65ab3dd5f6e15a235d0c4259c393e5d3428a43f573ea4aa6aba00f9ddc4d08fc3149f9f1903acc6ea849262f4d5d8dbcb02e0dc3dedc6eb4aac284514397d0e2f12bc0eab2c75e62bc6cd7ce8fe6e1bf9c81097102d67579f0920abd45f83726a18c8edbc735346d9b8dbb7d30502300250f6dab91b4bf84df12b2042f868796863f4cc05ec522c5e6251012fb6e2acfe1973a4de32da1043e291031345ab5a8e71cc09fbf4e8dede171d0d6a9db826c26c1e4209e4f94416aed56ddc9c426c7403f2ed8033d6a1fb8956a9fe0408daa4214eca68cb222234ea41a999a7218b3694fa912eebbc61064bda4de8e85934f6c2e4c9ab6ba055059d0e367e348b24d2725df5c71755fd5ebb8a0e8f371b941746385493265c9ba6518ff13b86c515a3bfa1fc57fbc8d7558de9c2033bc8ad914a64975aac1b1fe2ced3bc850921fd4e17750f73b5fbc5ed0fecb38d8bc1dad7086f2b2a93f92474aa095029b42137923cc1fe20f23557ab27c0dc41d1d286d97c32c8b55e40f140d72e07ad502500adbaae934190ba9236dc0f1b18bec31b3f78e92f66e816d95d692dc80f6dfa950c072300069ab6d1ed2afd70b5ba4414571f95dec6560471a38b8000ea890681395ce69dc16ee02d4c3d3b5ad99a0601ee0d29d142e1e5fd63c65061590fba3c6e41c207f42e0493930ce27a7ba80667ccaf4164651e9ab08ac99840b1825ecbf3874dd7e8b15eb8e7928bea8f08f2c6c7eb4fdb60e119f5e315500bcc8bc76bcd336a9a7e73c2f99b3e09da967815fb02ca26904cbe72e7a50ad78f9b110e681d80098798012fd84c23ec071c6042710f3dc8d52c5dcf9852e9a82179f8694b3ef8b5f87d6bba5e1d5b9babcdf9796f5eb7e0558d69db8285bb39419d3da9682439757e9593a6d024b4ab525c88b7ddf2e30e418bba421eb4cfae80a2652614a37b094f5ce462cab15d067e4d1dc8757bb0f67c148944f33f4300ef6e021b9074b03cf81a8c12964e05eb197e6e52957bfd6cdf9c551e664adee3091a42fd827f342c6b7e30535f509e12ea894b2d11ab6063f7ae9ee394b64d93138cd9d45ab762b6f700fbbe29409e875b20e64b390b056909b750b1b09191c92605c69a378b4d9c33a9411e33c2d20c84f09481769f0fa3bf6cdc45ae1fda1511966b4c381c90b73bc220ff434a63ef6d36bcb186add869eb0565f752185530cdaa91fb9418c614e4be1c06f7eb87c9b20edbdbdb9c9cda7e6488138bc61dbb4bab017827490b68333a57bc1bb22f721e672d4c52b62d850719169707124a3abc9ab129772041d959e980858dfaff80e3515381dbc9994831658c69d2152ac3bd729e8ed9b3bb2e2b69c1b5290420265d517c5e55cb50136ba5be17dace821a1d63295314f04af0438335328982c3b8cf31cd315d9e1aea718ffdd498ee9e06dad9e0c72b80520cd8f986a5166e108b492e2bde9ad7ab04fcbce421dc38cc767f40ffa03a79fb107808630574644bb6a145485d5c47472b0ae80bbf03b7ac0dc94bf34821bed0c10d71b9d21e91c2212e0d574031eb590e1f14c280a0c79e9b90b52b9cd86aad301bd121b862ed9137065da40c8b2de11d477947445c1defbb5b7dddc00506290cfb1735d9668141fb0e38cd78699f162adffb69e3c8033498d7e28ee6f05b00be2cd4ae95ea5ab39648039afd2118b49796c9b0ffc0214d759a1abf45b87e1c97dc4d98fee36e12b4d956f5f11c2df306573504e3a598160798f3aee5c8df23ddd8ff6548d09d8c2a8633e90d6811a09f50a827b87405bfec01d109ff9e0084e44d1cf4aeaa46e70e82aa94be2662a04af65458e126d21cd65806a63ecd1d2bfcc25caaeb9b1c30f73db2398eec6cf70cd0748dad539f3f085f78bc9c6fe56eaafa0219080100d4d9c9e7ce389e168a9c0480ced4f83fbf3f41a8c1447abca386d0020243aaef2ffc75d3d230bec7892b452556910e5f4f888bcaf447c9141567d3afe3d6043e198fcafb6d5d7579645ab8ed7644fc7683aff1d47c243e04ee6dad89a2b5707d389713d3dd4e128c69a80c5bfa175f0b67fecaf6e57084949298d7eb8ad2baff06854f8f6c74b005f43ba3c22990445bd8f9e85366f2de3adb664553c7bd774c6e0ba647760f273c5a9904f2b754958aedda359990351622df748bd4ad9cdd1ebf9a5875764fbf9ce5d8da4c882a62fbd7107c75352df897ed955439e20f58ddd3365c371053e8e4d0b6040bd166e28f00d9d873106ce5b03d22e3c557c60611099be4266b15c7e64de1f6531670b8a370b002a5e44f6c60d2d4e8dc83a362bec644eac312255dd75f0fbd3e1758117aa69b71f03f3f82256a4fc5b214606d256955946b20f2fda6eff85b46ab42b638f0d631790405cee4b87d4deb7caa1ca2e66cbe3d03132562faaff326b91b11e0553b3287bc2416da103f05ad62968b9214ceee571c6bc7b7fe12fb68ce12b0943831bd18d79c7f237852ff869b073239e4e25006d6f625899e4a0aa21be5a94293423c00c7380c8d1becc7c829f66453e622c042920806973ca1eee39ef21fd0f57c4a000c4b4ef8a3369e403ce0fb0da41413e9c10947fdfb195304ddd78bf1135262a25a564e185e8bcf7da720c617bc804376d113efb56a42aa1d4742dce5fc19fd256a773ecac3b0441bf23c444fa5e99954cad47b43d685cd226328a3623f3090b07063098c8658e71b82d4ba99ae66d41b69f1cb63d1be633a9cc3d4d2aa96a7c8a8a5550f2c99c6f77d736700d80f812fc5717f762c5c210f75b29b9d7619a56d6a39f7e132b4a69529d8a6f255ababd1cab9f0beb660c5dcb63902d37cb96f96007043e2d67a7e3a359ed8cf5da3c021d8cdeb961b755451f88fc9a07852cd3a226cd58e642a03902b3c111241395a9213f9657c28abeaf5eca0f2dfa12db42783ec28e364f1f99b6ab5edabac23d3b8726441ad19792c0a48c91ed5cd34dffc0398e57d6fe50688c9e65dd9efb62f5f0fdb6daddd9274d3368493c1e5d1dc5d50d7cebaee8a3481d718685c1070ad02bf5c83191db24d89b5548d17fc0668c7e45c1bf061c7af879e9232f65260fc37b90df3e709af5553274e595b2e1c6f3a39013d893935d3528403974448a10540b2f8741ec16e52523979ed04d564bfd7cc6fd7eade3eb7990c92c297a18044e6178a05e54f68e80b87204df0cbb6eec1c6b8d7c2fe6e6d738795f4976a1ab52619b3e232332f6b1104bb43501f269deb2bf62a2cfdde1d371b72fb04894cc42cad31b363b397c3f8f561cc39184eb1364ae24a7be171a0484624a6a8a68421b42d51ba421589f0d752f4b36af854f74092108d460954710b2aa22efcf2f83</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>404</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>contact</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>friends</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>search</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
