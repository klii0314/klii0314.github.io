<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>联合省选2022前的记录</title>
    <url>/2022/03/11/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892022%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="58d5f6be6eb2192cec6baa555fc6544413e5db074571e74343673994cb08906c">cd67862bdd141bb2aa1c78ab2fd399f6025480595d1e8c8c68d7bb7df6fc241012de68bb08422b6f66aa40e30ff3ba9897f4891827ea4427b65670833740266d8d21bb3e199773503e6edc7740dc576743fb6d95d69b06fbcc02676aea6d19c5ac639d10dfd106bb9dc39850099af7ff65d616d0f01194b07328c65d30bd35f1d4ef0d847d78998ec34cc7bde7144dbb6ec7807c29301eec9a59e20d98c7b49e2b3305ca621c9fb133c006f3b23b17b05a78ff540ebfa2fd0fa42ac5b59e26efc9a4153b24fb14b5a475fe221f73c49e51b2722abf28548597639c30b80d6d29785675e123144650e6a53cd47553b94846a1e256dda31713ef698f9c83be6e4ce31159d0a4e5a87ae12f94c3e3658c401aa33640b1c004c8fe61d1717966e667b6dc7ae3134fa6d6a3225e18ab920212836639db9b6f5047b38f09e09f1202596358b5a7d703c525f385b2598c2a3f8094ed396a7ef0b52ed9fda5393eaaeef0a5d5719c2db14b243bf12bec10fffcec50e9a8e201e073ffee8f228ad9d173cb19a6eee0c6818823483c4c841fccd76545763ba55ca7bf802ae8145dd4d12c4a126137ae710c4ef0b0d73aefe06fbc947a8a893ef5f10607856dfe195e8c8eddaabfc256466c8938f8f5341e98037a67ac34cc5b2896f5f3a5c0ac92b8d95806202d94982be671aac05786e410bf31aca34938968b194811a91424a17db4b4f776436a43dc1d16db45bd4e9fc1734cf223d6057a2ad06e43329ae79df55d10f01294e67de7c7af95b21e44139f3ab3f221ea6965cf89c48fbfa3e1be1e27181f4d9079d8a290b6e100afa920dba627c73ab0d718ccb70870bb0d2169e4bfaf4baad5bb74f7cfe3978551bf5740be864161baf68682c47e0da3a6257921b4c0e5232ea23f1240a5e9b7eb9532d4e98e387e42f3e29271a948156a9fcb39471b093f9d9db5ccaf78d7921ca7f8a800ccbd08e2002753721700c823cb3b5994b70e62e63d0ed162efaf93a123bb1977d7f9d3b6cf337b17788dff9ef4c1322ea6758d99ab4a64b4e76aaf7cc25ffe1dbf28148328b30a88c6961d7dddf45c759c599d139182fd374856c9934ab0cb19c940b016d6e0b2812f2d9031a2c70adacbb7feb5f4bfd63809abe643ded41d7a82f7b0b6b683f3e2578320bc625a281dc0043ef54714e7807580df9981e5cc14c28f17a8dd399ae27618cafe854d20a42386222fc2d61a7b30e1236ffe7a3833c4af2c71e0979256d2ec085f3d5c5f37e4ef221666871ce57d72e688ce09d3ae446b41be33cc07041bbe0db1e070797660dddc6e06a5a07a85b750706eefa7c0b0f6252905d3d7f5f3d20d1b176e385d716ba074289a58301564e5dc0af204a32d95b6590c7b2b16aae3ea4b04d8cde401c9daae02e529f4993e5e6c394de6fe4bb8391429f77490e04ff40927f85edb5e8c9e9b762fa0cd920afd42fb484e442767dadec10ee3b577e345d55e0aaf66d1be0eaa9fea6d75cd0f303958e68ae1bf730fd96a678ee85cb8c369160bce2558c5066526f7427fc054b7cf6dd1b09edbb44086a8070b86280d6996f6a58a812a80c01361fddd719c26635093290dd244fa60c6637fba4f9210940eacc8b48f20554e1efe45bda855d6f27cc191cb025b8bb45cabe6cbe52ac0ac851f3d8abacb8c303fb7feb22f66520f2bf5a2365aa9185f9da844ea57b3a007ed65d91f02608b2a621933c7156d2b83ec87c36fb5fb1cf417d8a466bc4d87f25ee1a08144f46aeacc2f1c3dd4ec32453400bc948b347cfecd217a83eaecb36b4efbc3128eedfba89026218098462ae8e69b4885a20b54918d366ceb836d343973b272972e611466f0dadaf02cf796ad1993bdd105a43fcf41b6401cfa72d3f543a17133d0036c3f08f16db598b6edcafbea3730fde8fc80c731f3888fcf35065672ef344e7cb85cd11410497f9fbb2978fb6d01093987707e530262b382c60d89d43f283fddc7144870790fc7a89226401d3fa8435585ce1cda78592422611bdc26424b3c3bd02d960d0aeb5bcb781cc52a1bb644b3ca2b3c998333244c2ac2969486a6e42b1419a545ce542b40d50ae2281849b5ed67a8460c6754a3b89f4579bb1af614a5c806301401a56079db61cfb3b6a1e741a113c0b2d91782ec1bea4f374f0f4a7c6aaea8b3a03a734c8516dff03d15c114f25e2f6104da41b83bc9b351fe6408ef2a2085998c9e577ed1974fa0152dce8032191ced18714071d580579cfe59dda55616f17706fed51ede5141b12a008eb61545901687a56d725b732d5e57541b1b822923b796b403bd504e07861d89bc63d620d7c0b6dfdccac39537537b61abb0ee16b76678f6aac4b21e402c4105c2398535de9e0194226f6be8b8b76d88a6e543d4c583998ab1dd30fb20c33d820163ca9d44c5e81c7b105672cbd19e7539dffa0b9268767171e748902ba070f2d010ff61a1377a86d9d13f4cfc821b8909c2d5bef12d7e7e49f3b741724b5e07c51af7db02274f6a4a4fc48d21a62727e080e972b3e4493a7cde65fd74a466027b7554bd19a79fbc1de4c72c7a52ed1e84495e57eb03ffed0a2af20f62fff401e6797771dc903ab431b1299f3c8b9cb7d46b7eb7ca5144d576fb6c45098b5b438850dc4cfc32f6027a72c9f066bd55fd0b9e4cbdea75641e4815a45f94b4cae2c3b32eb280353c17c8f4d6c3e637e50085fa3893cebb62166b9a009f29a7de2431ef05cb92e619f4b2b656c51385d38b755b8c54ab71b7bc27097310fd6bf0e98e72520c14da84bcd8a0ff9c24a8ad64785bad9c82c97ffa2931baa91d7fd558056d7130282bea41c3b15fed9a9b40d6f2ba5521a3c0d1cc042e2eb86d0fb8ebf44119564093fc87274fcc187969e770579ea8af9bc56cba7439a84dacbe803eea10d0116b23b485554b09270853961f797e3c90dd8f1db0b381eea93470151d8fd5d975696159f0e427e45eeb2ab70e43f414bff8dbe2971f18c0fc976cc512ba745fe0ea36cc1d35a3d2b76177e87d00b08fa7bce7c83a29ea02624942e2d649ce37ffa60956061c18ddbef36b5d1e64dc3f39b19a1274aa4e59edecbe6ad013e095b74765d965a0b5e265647e69ad463effa665e73ed39a08d729d1af616ac867b5ff3933b995c46e358f6384c10d7336b38c05e9034c8ce0f6ee7fb6f0089784bbc0487e54c0daf5a3259f41edb5b56dc4602eacee5417201dcd6a57655c87b89c99d7061acae5b0d202b070da6ab3608fb05ff1318e03b2d62fc73c260b8fd29cf2264b0a3b92c4eabb30481470f720d9f825d6e2ef1ac767aed4a6366c12655bd703420fb5812bc870c892d577e17871c8b73e61dd7b3055cd9a19e4343aa1994ae38d443579da51a82cdadf0633faac535a27ad76b4957f61e6871ab26277f1e2c8ac25b02668b8f675eb9660dc765a2a3541186ea6f520c7bba024cf03b6a08a8e31aa0f5113a31e900e577fcd633861379edcbbde7037451b353eff638f96ebb550025a6687580d2ee581db32a8aa41266689387eb89460d6f0db5f7e562adc16ae883843e8a3fbd274851bb4b0ec91a6a1c274de7c120551b8456d92ae44a77a5d521b6a87581d48ed74e5b46b15c1349d5d37c33526f1e5e7c37589f409d8e691e6ab99dd7ac87dbbd6c3c24edcee737691884c3f0209f9c85b86ee6e0542696dfc32ce5aef2c4aa5f0f6d14c3737fa2e2f981d19ce68b6ceae137b65f502ec0d625bef1ffdcbca7fe12fc843a872484093c28df3e2e38d4184385b2e3d933894297a783df7b67346404610afb72b5563a8534939fa2e7518f67f5ba53e92ac6adb5f01e796f586d4195cf75ccf24a091cff289080b4f0dca8abf629f3a6cf3272d232485917c3bb61a6279b85cc17e89d203bba37ae71c5f5ea5a78f11dae26c91d009b2cf3e3c53e63fe9e5b9da42bc4399e4c10368a16a13d61377487bd3fdafaadbbdd1a63ae2586587166ef37c09059d002cd3ea34a679c5aa6f01b0c6b8581ce62ddcc6060e2c3462ebf402bcab80954ed6d3750565e9dd8092bf74317efadc16ba90446883e1b6c8eff35b5d3aed677752fc4df4e47c481157099d8ed1db4fd3e8581c24911f520f01c320293ae9761fb5492505e1e4f534ee140b76406b6f0bfa7055b48bb12273a029d57d02dbaf9b997e55dcc882566e615f8d759c50f00e4922a5707b5b5bcf150fe4ac899df751067ff6c076887129a95bd07de35ba2bb464409421ca0eda38a98c73dd8ba3a9ccc2cb4a35a39eee1377f7b2ccbce02d898590d1c8ca01403bc8486d56afdf7f04cf81ad3f0e5e18765bca5f4a6ae5cbd7992155c8c2b856b5409a10e0fad494d19b32badbb6ee5c1d7c2914c6fcf1cd7a079afe59d157998377356c088fae9001dbee40080f60d9ae0935f25362ade4454ab88e277bb83787d968020d5e6f43c830dd3695a31e89a0402af68d55097a2142c6423d592ad2258eb19e93434bbabd070563853518839c37d3d91ebe9df6048bc5db5e15c9fe9abc2fd19c1bc08ffe034a24187c4cb2eda0797ed8c4ca6a60bc356dc6fac1535b34a5f89e2049a8387713b5a0e8f9911726ea33841e7d356a6e32cc21d68f392dcdf9bd4acb651fa0519edddbf946472a3c1e3de98653f2db86fe6595b2717e7077ec3c9eb1367181223feae4bbe2670c18457aa9b46b4ac3f8b01e3dcb14b14ada8a2a419a89bc0254a88495b3b7bd797a8ff924689c879a42e880950381ee249a7214b08ae0543827703255ff953350503f675ee438eb46d31b5348b8aa892a3b51893e1b2587c2d6b33934a1fb1ee4e915c3ae24a0256fec010b2ab1bfc7a7a7fe8987cc3510d0fe9b5ba4817642d7dc10cda0bb623ccb360dec99a4a483a5c097a97ba11238a299110f01c3537aeae4df10898aa54a19214724235606f52932f51e15fc5f7fc5e1067d7aae76e5878dfcc89b78e35f681025f0c6e27b8b2a6e64706559a90513759fd75d75f8062c656ee37bde8f693466080c827ba7d18b4feb0538bf6ca8765091ecdeedcef5b4fb21ea4c4650d8451757c52da40f168ef0ffb530bd9850d8faf4011eeba438969f774287d40e09cc930cbeb804881b1e01ee1f797df15be2437701887a5aa23e03c261823e4f03b5b2ea1c9225954a842b1185fee176fecbce208ebc5036ce7fb0296a7ffd8ee10bde5df1cd4c1793c806ce47e597783703aa4a147e713854bddcf7b55e01d491f97ee062f9965e4f6bdc9778c54bec29d554a0e9edcbdfcd26950193d63af6c9e8a92b1423bee996248c4b9259f7edeef2dfbc674a8936c96f1b8720386e67f7775f2d272baaebdff1e21d04ee569f38e144c88ebe30c3b18922f86eda8bf5915c03fcf372837a185db019306481eaaf375556b49856b7949424954deb3b939c51f6876fafd95383e7e783dcb4ac09afa43460aa8a6a8787368390abd42c347e08f412a21d163a7298d3c6e1548e1ef72c603cd6e930dfd19c280713b31d97e7159531cae2e4ee4d7a0a2a89218473f1b1430b7b7fcef60ac1c8c18aebe181b8f872beec074fd4810187c3aaf6a5e183a1f3f97093bf6bb6c6cd38134e18c876f392b6515f4ebad58165b37d2943ab96d097b3f4028eaa417d88136639e75a9fc9b8ae2a3f7ee69d1838991c71f317839c72a7c5a1b2b92ee1aff9a2ab01e106245e334e7f3d853845b14814c3bca8f9eb0acb6085fb13afda949f91f9fc2d8d7934b2a860cf28412cfa0ba285f85d345218c5402cadb5daf47ecbb7e53e122224f6734c3c01bf63813d715ba4c74938a7b0054c7a216b034afd279fce631b0fe7e1d906327f1440cf59a5e3adc48a5cdcfe11233d80b0c1aa5f98cd497ae546416dd0a911745c14ce2f7c071de83021c226e0df32d22f018c61d005f7da45750b93e892796da73a19ccad8db6da18b9efa99eb7e0eb2fa1e95f444f9731f396a5f670f95a2ba7ea6c3deebdf18e300d3e297efa705b3ac6977102fb1402d1784f101190e4acfa84569d02770a71aa90dc3bcc26d295064da0856ebdc07fa73310251e6edb702b89398832037e5387c115b6a75c3cee3648336139adb9b05cecadd634cd019abf228bf806df07443e0dd495adce6b2fad33892162a7f51362b69b4b6930419f34fb5642b835d6704c27affb892ec89441a95b5c677f98a83be5f184be8c956db94f22ac8b2b88eee2c6c0b6112e2a8eeade763bf2df34da8eafe99c8647d1358d76e7f550dfbdb9ce3eac28ed15ce4efd58216cdf917a5509c2e1c37992e9c8980dd6e2b73a8fee1da883fb254100e79070049b561eda623d9817d58d139ff679c2b73a1a7abf643bb28f457769ade362eb3bd0a2ca95e94ebe199f8981776848afe711c9e3f86dd2756349a3c14219c81f25da705e9c781a38dfeda1fdd8e672dff045631334cd1b5d25caafcec537fd2f563ad21bf10b61f0b18469abf4817c1f233f7311a37232dabc1485ea467f6e3e1bdfe5e68cfe7e3d155fc927e2791fd2d79076366efd7468518f16ec9a0e471078200ad15829f3cb805ead83d182490f8bd7a6301faa36db8c04661441067d9f2b61df38795bbb2fc7349521820c24dd2d72c8e6f496788340b73c6ea9fbc82783576187f1946441bfa6767deda7208536063601fe15e0c74fdeeb10e873b74b37bb54961458a106e331b3a89094441fdcd356aea7cae3aa9cf0d33117ef85e7f152bbaf27c484d9a88f488c55853472219b80bc67d69291f77c1dd931f1a1e3dbec38c5b18f7ae1e47feea71aeee588b7ba3479555730af707ad738453ed8e3e661fbd3c08ea78b317e0bdab913fce626387cbe64d4152df8377392a4fc70eaa1b0f89f983337843ad9e13f9a800cb6677f13a57850abd16d2a7be3e2a50c6f3dc93806aa96f33e9d803e2da3dd5eb60e071e71e5058b4aade5f8de61998dbae64ba2f383a306d5cdc4c511daae8f8ae800f0de09e8a0b7e97d2110b38616a8ec66efaa06857c0e8c8d73e534c27498a139e4be1a15bfa295e3a33bdbab073b2b5712048bd34f1001d38e906f37b8ae1abcd9d628a86123c4d85528fd4d858ef3456733edd95821e1bfbddec01b74005994e85364e21f66afc491f5680b098ecc30bd1ec0df47d427cf8407520d204e1855868940a5dfd86cfa6674f7f4c0f3e2871018af2bcafc72010eb252353e615b71e591874ab802852d688a16f93170a92c381a0a7096337f8c504f802e8f20434975d6dd1e72ffa1a0c8b7c17d3aff5f4c8c96a901e87c581266216a4ea6e3f98e9fd90df2c38fc8c24a3db08082200ac1232c8ac005862c2503dd521dabd759303b77481617729b7453238b6af54d3e7227c0e19ace65452facbc039cdf7815fe84225f1d37761606afc6f666d5dbd22c31c58003b77258853d6fff3b00f93334e35f153a87dca6d145eee7c0174ecd61e19041190d80506dd33800d0d8cd3c3dbf393d03bbc87349f6a952acead63f15decda977eae1af372a3b4c235d04fa26b445b37695886496d13e9efe7c80355f7195351f8228c341030374f30c64b9a001978d155277ee182cba8d47fbc7e93a82f4a90d537d76cd92ef42e647f7c53d19e92f17d07d5c7a90c55b879d1510a46a654312059d89ac97caf3adf51b53831036a59922137b0ba78d8b9059596ca781d331689799df5f67e2891a4da17523a04bbfec6fb06644bc38edfdbb3ccda49</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title>CF1017G The Tree</title>
    <url>/2022/03/17/CF1017G-The-Tree/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1017G">$\text{link}$</a></p>
<p>对于询问 $\text{3 x}$ ，若操作 $\text{1 y}$ 使得 $x$ 染上了黑色，那么满足 $y$ 是 $x$ 的祖先并且 $y\longrightarrow$ 路径上操作 $1$ 的个数 $\ge$ 路径上的总点数（包括 $x,y$）。</p>
<p>考虑给每个点附一个权值 $-1$ ，操作 $\text{1 x}$ 则对 $x$ 单点 $+1$，那么查询时只需要判断 $x\longrightarrow rt$ 的路径上的后缀和最大值是否 $\ge 0$ 即可判断颜色，如果没有操作 $2$ 就做完了。</p>
<p>对于操作 $\text{2 x}$ ，将 $x$ 子树的权值覆盖为 $-1$ 可以使得子树内的点到 $x$ 的后缀和最大值正确，但是可能 $x\longrightarrow rt$ 的后缀和最大值出错，这需要将 $x$ 单点减小 “$rt\longrightarrow x$ 的后缀和最大值 + 1” ，然后就做完了。</p>
<p>时间复杂度 $\mathrm{O(n\log ^2 n)}$ 。</p>
<p><del>久违的 1A</del></p>
<p>$\texttt{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];
<span class="hljs-type">int</span> n, q, s[maxn], fa[maxn], depth[maxn], son[maxn], top[maxn], tms, dfn[maxn];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath)</span> </span>{
    s[u] = <span class="hljs-number">1</span>; fa[u] = fath;
    depth[u] = depth[fath] + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) {
        <span class="hljs-built_in">dfs1</span>(v, u);
        s[u] += s[v];
        <span class="hljs-keyword">if</span> (s[v] &gt; s[son[u]]) son[u] = v;
    }
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> Top)</span> </span>{
    top[u] = Top; dfn[u] = ++tms;
    <span class="hljs-keyword">if</span> (!son[u]) <span class="hljs-keyword">return</span>;
    <span class="hljs-built_in">dfs2</span>(son[u], Top);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) <span class="hljs-keyword">if</span> (v ^ son[u]) <span class="hljs-built_in">dfs2</span>(v, v);
}
<span class="hljs-keyword">namespace</span> _Smt {
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> lson ls, l, mid</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rson rs, mid + 1, r</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> len, s, rx, tag;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag = <span class="hljs-number">1</span>; s = -len; rx = <span class="hljs-number">-1</span>;}
    } t[maxn &lt;&lt; <span class="hljs-number">2</span>], ept;
    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{
        c.s = a.s + b.s;
        c.rx = <span class="hljs-built_in">max</span>(b.rx, a.rx + b.s);
        <span class="hljs-keyword">return</span> c;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
        t[u].len = r - l + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (l == r) {t[u].s = t[u].rx = <span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>;}
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(lson); <span class="hljs-built_in">build</span>(rson);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        <span class="hljs-keyword">if</span> (t[u].tag) {
            t[ls].<span class="hljs-built_in">ladd</span>();
            t[rs].<span class="hljs-built_in">ladd</span>();
            t[u].tag = <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (l == r) {t[u].s += y; t[u].rx += y; <span class="hljs-keyword">return</span>;}
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(lson, x, y);
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf1</span>(rson, x, y);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(); <span class="hljs-keyword">return</span>;}
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(lson, x, y);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rson, x, y);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(lson, x, y);
        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rson, x, y);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(lson, x, y), <span class="hljs-built_in">qry</span>(rson, x, y));
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        Node res = ept;
        res.rx = <span class="hljs-number">-1e9</span>;
        <span class="hljs-keyword">while</span> (top[u] ^ <span class="hljs-number">1</span>) {
            res = <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[top[u]], dfn[u]), res);
            u = fa[top[u]];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, dfn[u]), res).rx;
    }
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> lson</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rson</span>
}
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;q);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-type">int</span> u; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;u);
        G[u].<span class="hljs-built_in">push_back</span>(i);
    }
    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
    <span class="hljs-keyword">while</span> (q--) {
        <span class="hljs-type">int</span> opt, x; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;opt, &amp;x);
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {
            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + s[x] - <span class="hljs-number">1</span>);
            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], -<span class="hljs-built_in">ask</span>(x) - <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-built_in">ask</span>(x) &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"black"</span> : <span class="hljs-string">"white"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队二次离线学习笔记</title>
    <url>/2022/03/17/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P4887">$\texttt{Luogu P4887 [模板]莫队二次离线}$</a></p>
<p>设莫队指针移动时间复杂度为 $O(k)$ ，则普通莫队的时间复杂度为 $O(m\sqrt n k)$ ，使用莫队二次离线可以变成 $O(m\sqrt n + nk)$ 。</p>
<p>本题直接莫队做是 $O(m\sqrt n\binom{14}{k})$ 的，无法通过。</p>
<p>记 $a_x$ 对区间 $[l,r]$ 的贡献为 $f(x,[l,r])$，<strong>差分</strong>后贡献记为 $f(x,r)-f(x,l-1)$，即 $f(x,r)$ 表示 $x$ 对前缀 $[1,r]$ 的贡献。考虑莫队指针移动过程中答案的变化：</p>
<ul>
<li><p>$[l,r]\longrightarrow [l,qr]:$</p>
<ul>
<li><p>$qr &gt; r:$ 答案增加 $\sum\limits_{i=r+1}^{qr}f(i,i-1)-f(i,l-1)$</p>
</li>
<li><p>$qr &lt; r:$ 答案减少 $\sum\limits_{i=qr+1}^r f(i,i-1) - f(i,l-1)$</p>
</li>
</ul>
</li>
<li><p>$[l,r]\longrightarrow [ql,r]:$</p>
<ul>
<li><p>$ql &lt; l:$ 答案增加 $\sum\limits_{i=ql}^{l-1} f(i,r)-f(i,i)$</p>
</li>
<li><p>$ql &gt; l:$ 答案减少 $\sum\limits_{i=l}^{ql-1} f(i,r)-f(i,i)$</p>
</li>
</ul>
</li>
</ul>
<p>$f(i,i)$ 和 $f(i,i-1)$ 都是固定的，可以预处理直接计算；</p>
<p>$f(i,l-1)$ 和 $f(i,r)$ 则使用扫描线解决，具体地说：</p>
<ul>
<li><p>对于每个前缀 $[1,i]$，开一个 $vector$ 存下所有的询问 $f([l,r],i)$，记 $g(x)$ 表示 $a_{[1,i]}$ 中 $\oplus x$ 的二进制表示下恰好有 $k$ 个 $1$ 的个数，则对于询问 $f([l,r],i)$ 的贡献即为 $\sum\limits_{i=l}^r g(a_i)$。</p>
</li>
<li><p>处理完 $[1,i]$ 然后处理 $[1,i+1]$ 时，枚举 $a_{i+1}$ 取反 $k$ 位更新 $g$ 即可。</p>
</li>
</ul>
<p>询问可以用四元组 $(l,r,id,1/-1)$ 表示询问 $f([l,r],i)$，询问编号 $id$ 以及增减 $1/-1$。</p>
<p>$\texttt{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> f ? -x : x;
}
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, k, a[maxn], B;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {
    <span class="hljs-type">int</span> l, r, id, pos;
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> _ques &amp;a) <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> pos ^ a.pos ? l &lt; a.l : pos &amp; <span class="hljs-number">1</span> ? r &gt; a.r : r &lt; a.r;
    }
} qr[maxn];
<span class="hljs-type">long</span> <span class="hljs-type">long</span> sum[maxn], ans[maxn];
<span class="hljs-type">int</span> f[maxn], g[maxn];
vector&lt;<span class="hljs-type">int</span>&gt; trs;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">st</span> {
    <span class="hljs-type">int</span> l, r, id, dt;
    <span class="hljs-built_in">st</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> dt = <span class="hljs-number">0</span>) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">r</span>(r), <span class="hljs-built_in">id</span>(id), <span class="hljs-built_in">dt</span>(dt) {}
};
vector&lt;st&gt; vec[maxn];
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();
    B = <span class="hljs-built_in">sqrt</span>(n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
        <span class="hljs-type">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();
        qr[i] = (_ques){l, r, i, l / B};
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>); S++) {
        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++) cnt += S &gt;&gt; i &amp; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (cnt == k) trs.<span class="hljs-built_in">pb</span>(S);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        f[i] = g[a[i]];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> S : trs) g[a[i] ^ S]++;
    }
    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(g));
    <span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + m + <span class="hljs-number">1</span>);
    <span class="hljs-type">int</span> l = qr[<span class="hljs-number">1</span>].l, r = qr[<span class="hljs-number">1</span>].r;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>; i &lt;= r; i++) sum[<span class="hljs-number">1</span>] += f[i];
    <span class="hljs-keyword">if</span> (l &lt; r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(l + <span class="hljs-number">1</span>, r, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
        <span class="hljs-keyword">if</span> (r &lt; qr[i].r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(r + <span class="hljs-number">1</span>, qr[i].r, i, <span class="hljs-number">-1</span>));
        <span class="hljs-keyword">if</span> (r &gt; qr[i].r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(qr[i].r + <span class="hljs-number">1</span>, r, i, <span class="hljs-number">1</span>));
        <span class="hljs-keyword">while</span> (r &lt; qr[i].r) sum[i] += f[++r];
        <span class="hljs-keyword">while</span> (r &gt; qr[i].r) sum[i] -= f[r--];
        <span class="hljs-keyword">if</span> (l &gt; qr[i].l) vec[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(qr[i].l, l - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (l &lt; qr[i].l) vec[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(l, qr[i].l - <span class="hljs-number">1</span>, i, <span class="hljs-number">-1</span>));
        <span class="hljs-keyword">while</span> (l &gt; qr[i].l) sum[i] -= f[--l];
        <span class="hljs-keyword">while</span> (l &lt; qr[i].l) sum[i] += f[l++];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> S : trs) g[a[i] ^ S]++;
        <span class="hljs-keyword">for</span> (st qry : vec[i]) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = qry.l; j &lt;= qry.r; j++) {
                sum[qry.id] += qry.dt * g[a[j]];
                <span class="hljs-keyword">if</span> (j &lt;= i &amp;&amp; k == <span class="hljs-number">0</span>) sum[qry.id] -= qry.dt;
            }
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
        sum[i] += sum[i - <span class="hljs-number">1</span>];
        ans[qr[i].id] = sum[i];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans[i]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ul>
<li><p><a href="https://www.luogu.com.cn/problem/P7906">$\text{[Ynoi2005] rpxleqxq}$</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5047">$\text{[Ynoi2019 模拟赛] Yuno loves sqrt technology II}$</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5501">$\text{[LnOI2019]来者不拒，去者不追}$</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5398">$\text{[Ynoi2018] GOSICK}$</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>群论学习笔记</title>
    <url>/2022/03/16/%E7%BE%A4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>参考资料： <a href="https://www.luogu.com.cn/blog/command-block/qun-lun-xiao-ji">command_block’s blog</a></p>
</blockquote>
<h1 id="群的概念及基本性质"><a href="#群的概念及基本性质" class="headerlink" title="群的概念及基本性质"></a>群的概念及基本性质</h1><ul>
<li><p>由集合 $G\neq \emptyset$ 和 $G$ 上的二元运算 $*$ 组成。</p>
</li>
<li><p>满足以下性质：</p>
<ul>
<li><p>封闭性：$\forall a,b\in G,$ 均有 $(a*b)\in G$。</p>
</li>
<li><p>结合律：$(a*b)*c=a*(b*c)$ 。</p>
</li>
<li><p>存在单位元：存在 $\epsilon\in G$ 使得 $\forall a\in G$，均有 $a*\epsilon=\epsilon *a=a$ 。</p>
</li>
<li><p>存在逆元：$\forall a \in G,$ 均存在 $b\in G$ 使得 $a*b=\epsilon$。</p>
</li>
</ul>
</li>
<li><p>定理：单位元唯一。证明略去。</p>
</li>
<li><p>定理：每个元素的逆元唯一。证明略去。</p>
</li>
<li><p>定理：对于任意的有限群 $G={\epsilon,a_1,…,a_n}$，$\forall a\in G$，均存在一个常数 $b$ 使得 $a^b=\epsilon$，且有 $a^{-1}=a^{b-1}$ ，称 $b$ 为 $a$ 的阶。证明略去。</p>
</li>
</ul>
<h1 id="置换与置换群"><a href="#置换与置换群" class="headerlink" title="置换与置换群"></a>置换与置换群</h1><ul>
<li><p>置换的定义：有限集合到自身的双射称作置换。</p>
<p>  可以写作</p>
<p>  $$\large\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\end{pmatrix}$$</p>
</li>
<li><p>置换的乘法：相当于将映射叠加。</p>
<p>  性质：</p>
<ul>
<li><p>置换的乘积还是置换。</p>
</li>
<li><p>满足交换律。</p>
</li>
<li><p>单位元为 $\large\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\1&amp;2&amp;3&amp;…&amp;n\end{pmatrix}$</p>
</li>
<li><p>$\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\end{pmatrix}$ 的逆元为 $\begin{pmatrix}p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\\1&amp;2&amp;3&amp;…&amp;n\end{pmatrix}$</p>
</li>
</ul>
<p>  一般不满足交换律。</p>
</li>
<li><p>置换群：由上面的性质可知对 $1..n$ 作用的所有置换形成一个群。一般只研究一个子群。</p>
</li>
<li><p>置换的循环：把置换看作有向图，连边 $(i,p_i)$，会形成若干个环。</p>
<p>  置换可以用这些环来表示，并且是唯一的。</p>
</li>
</ul>
<h1 id="text-Burnside-引理-与-text-Polya-定理"><a href="#text-Burnside-引理-与-text-Polya-定理" class="headerlink" title="$\text{Burnside}$ 引理 与 $\text{Polya}$ 定理"></a>$\text{Burnside}$ 引理 与 $\text{Polya}$ 定理</h1><p>设 $G$ 为 $1..n$ 的一个置换群。</p>
<ul>
<li><p>不动点：对于 $p\in G$ ，若 $p_k = k$ 则称 $k$ 是 $p$ 下的不动点。</p>
<p>  $p$ 下的不动点个数记作 $c(p)$。</p>
</li>
<li><p>$\text{k}$ 不动置换类</p>
<p>  对于 $p\in G$，若 $k$ 是 $p$ 下的不动点，则称 $p$ 属于 $\text{k}$ 不动置换类，记作 $p\in Z_k$。$Z_k$ 为 $G$ 的一个子群。</p>
</li>
<li><p>等价类：等价类 $E_k$ 为对元素 $k$ 任意施加 $G$ 中的置换所能到达的元素集合。</p>
<ul>
<li>定理：当 $x,y$ 同属一个等价类时，有 $|Z_x| = |Z_y|$。证明略去。</li>
</ul>
</li>
<li><p>轨道-稳定子定理：</p>
<p>  $$|Z_k|\times|E_k|=G$$</p>
<p>  证明略去。</p>
</li>
<li><p>$\text{Burnside 引理}$ ：</p>
<p>  记 $l$ 为 $E_{1..n}$ 中本质不同的等价类个数，则有： </p>
<p>  $$l = \large\dfrac 1 {|G|}\sum\limits_{p\in G}c(p)$$</p>
<p>  即等价类个数 $=$ 所有置换下的不动点总数的平均数。</p>
</li>
<li><p>$\text{Polya 定理}$:</p>
<p>  设有 $n$ 个元素，每个元素有 $m$ 种染色方案。</p>
<p>  设 $G$ 是 $n$ 个元素的置换群，则染色总方案数为：</p>
<p>  $$\large\dfrac 1 {|G|}\sum\limits_{p\in G}T(p)$$</p>
<p>  其中 $T(p)$ 表示在置换 $p$ 下不动的染色方案数。</p>
</li>
</ul>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p><a href="https://www.luogu.com.cn/problem/P4980">$\text{[模板]Polya 定理}$</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4916">$\text{[MtOI2018]魔力环}$</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4727">$\text{[HNOI2009]图的同构计数}$</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4128">$\text{[SHOI2006] 有色图}$</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>CF1109F Sasha and Algorithm of Silence&#39;s Sounds</title>
    <url>/2022/03/16/CF1109F-Sasha-and-Algorithm-of-Silence-s-Sounds/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1109F">$\text{link}$</a></p>
<p>首先考虑计算每个左端点对应的合法右端点的个数，可以发现随着 $l$ 的增大，使得 $[l,r]$ 不存在环的最大的 $r$ 是单调递增的，然后我就不会了。。。</p>
<p>看了题解才想起来可以利用树“点数-边数=1”的性质计算，于是拿棵线段树顺便维护一下“点数-边数”的最小值以及最小值的个数就好了，因为 $[l,l]$ 显然满足 “点数-边数=1” 。</p>
<p>时间复杂度 $\mathrm{O(nm\log(nm))}$ 。</p>
<p>这种性质还是要想的起来啊。</p>
<p>线段树四倍空间 /fn/fn/fn</p>
<p>$\text{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, nm, a[maxn][maxn];
vector&lt;<span class="hljs-type">int</span>&gt; G[maxm];
<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;
<span class="hljs-keyword">namespace</span> LCT {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>], fa, tag;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clr</span><span class="hljs-params">()</span> </span>{ch[<span class="hljs-number">0</span>] = ch[<span class="hljs-number">1</span>] = fa = tag = <span class="hljs-number">0</span>;}
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag ^= <span class="hljs-number">1</span>; <span class="hljs-built_in">swap</span>(ch[<span class="hljs-number">0</span>], ch[<span class="hljs-number">1</span>]);}
    } t[maxm];
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">nrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">return</span> t[t[x].fa].ch[<span class="hljs-number">0</span>] == x || t[t[x].fa].ch[<span class="hljs-number">1</span>] == x;}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y)) t[z].ch[t[z].ch[<span class="hljs-number">1</span>] == y] = x;
        t[t[y].fa = x].fa = z;
        <span class="hljs-type">int</span> gx = t[y].ch[<span class="hljs-number">1</span>] == x;
        t[y].ch[gx] = t[x].ch[gx ^ <span class="hljs-number">1</span>];
        t[t[x].ch[gx ^ <span class="hljs-number">1</span>]].fa = y;
        t[x].ch[gx ^ <span class="hljs-number">1</span>] = y;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-keyword">if</span> (t[x].tag) {
            t[t[x].ch[<span class="hljs-number">0</span>]].<span class="hljs-built_in">ladd</span>();
            t[t[x].ch[<span class="hljs-number">1</span>]].<span class="hljs-built_in">ladd</span>();
            t[x].tag = <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-type">int</span> stk[maxm], top;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-type">int</span> u = x;
        <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">nrt</span>(u); u = t[u].fa) stk[++top] = u;
        <span class="hljs-built_in">pd</span>(u); <span class="hljs-keyword">while</span> (top) <span class="hljs-built_in">pd</span>(stk[top--]);
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nrt</span>(x)) {
            <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y) &amp;&amp; ((t[z].ch[<span class="hljs-number">0</span>] == y) == (t[y].ch[<span class="hljs-number">0</span>] == x))) <span class="hljs-built_in">rotate</span>(y);
            <span class="hljs-built_in">rotate</span>(x);
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; x; y = x, x = t[x].fa) <span class="hljs-built_in">splay</span>(x), t[x].ch[<span class="hljs-number">1</span>] = y;}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x); t[x].<span class="hljs-built_in">ladd</span>();}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">mrt</span>(x); <span class="hljs-built_in">access</span>(y); <span class="hljs-built_in">splay</span>(y);}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">split</span>(x, y); t[x].fa = t[y].ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;}
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">frt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x);
        <span class="hljs-keyword">while</span> (t[x].ch[<span class="hljs-number">0</span>]) <span class="hljs-built_in">pd</span>(x), x = t[x].ch[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">splay</span>(x); <span class="hljs-keyword">return</span> x;
    }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-built_in">mrt</span>(x);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">frt</span>(y) == x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        t[x].fa = y; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}
<span class="hljs-keyword">namespace</span> _Smt {
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> mn, sz, tag;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{mn += x; tag += x;}
    } t[maxm &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{
        <span class="hljs-keyword">if</span> (a.mn &lt; b.mn) c.mn = a.mn, c.sz = a.sz;
        <span class="hljs-keyword">if</span> (a.mn &gt; b.mn) c.mn = b.mn, c.sz = b.sz;
        <span class="hljs-keyword">if</span> (a.mn == b.mn) c.mn = a.mn, c.sz = a.sz + b.sz;
        <span class="hljs-keyword">return</span> c;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        <span class="hljs-keyword">if</span> (t[u].tag) {
            t[ls].<span class="hljs-built_in">ladd</span>(t[u].tag);
            t[rs].<span class="hljs-built_in">ladd</span>(t[u].tag);
            t[u].tag = <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (l == r) {t[u] = (Node){y, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}; <span class="hljs-keyword">return</span>;}
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf</span>(ls, l, mid, x, y);
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(z); <span class="hljs-keyword">return</span>;}
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);
        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>((Node){<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, <span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));
    }
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>
}
<span class="hljs-type">int</span> lx;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lk</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++) {
        <span class="hljs-type">int</span> v = G[x][i];
        <span class="hljs-keyword">if</span> (v &lt; l || v &gt; x) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (!LCT::<span class="hljs-built_in">link</span>(x, v)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
                <span class="hljs-keyword">if</span> (G[x][j] &lt; l || G[x][j] &gt; x) <span class="hljs-keyword">continue</span>;
                LCT::<span class="hljs-built_in">cut</span>(x, G[x][j]);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        lx++;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-type">int</span> dt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> r)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[x]) {
        <span class="hljs-keyword">if</span> (v &gt; r || v &lt; x) <span class="hljs-keyword">continue</span>;
        LCT::<span class="hljs-built_in">cut</span>(x, v);
        <span class="hljs-comment">// printf("? %d %d %d\n", x, v, r);</span>
        _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, v, r, <span class="hljs-number">1</span>);
    }
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> r = <span class="hljs-number">2</span>;
    _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt; nm; l++) {
        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>
        <span class="hljs-keyword">while</span> (r &lt;= nm) {
            lx = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">lk</span>(l, r)) <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">// printf("%d %d %d\n", r, qry2(1, 1, nm, r - 1), lx);</span>
            _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r, _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r - <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>).mn + <span class="hljs-number">1</span> - lx);
            r++;
        }
        ans += _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l, r - <span class="hljs-number">1</span>).sz;
        <span class="hljs-comment">// printf("%d %d %d %d\n", l, r - 1, _Smt::qry(1, 1, nm, l, r - 1).mn, _Smt::qry(1, 1, nm, l, r - 1).sz);</span>
        <span class="hljs-comment">// for (int i = l; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>
        <span class="hljs-built_in">ct</span>(l, r - <span class="hljs-number">1</span>); _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);
        <span class="hljs-comment">// puts("?");</span>
        <span class="hljs-comment">// for (int i = l + 1; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>
        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>
    }
    ans++;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m); nm = n * m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i][j]);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i - <span class="hljs-number">1</span>][j]);
        <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j - <span class="hljs-number">1</span>]);
        <span class="hljs-keyword">if</span> (i &lt; n) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i + <span class="hljs-number">1</span>][j]);
        <span class="hljs-keyword">if</span> (j &lt; m) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j + <span class="hljs-number">1</span>]);
    }
    <span class="hljs-built_in">solve</span>();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>LCT</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>CF232E Quick Tortoise</title>
    <url>/2022/03/15/CF232E-Quick-Tortoise/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF232E">$\text{link}$</a></p>
<p>先将询问离线下来分治，设当前分治区间为 $[l,r]$ , $mid = (l + r) &gt;&gt; 1$，考虑处理左上角到右下角的询问，剩下的分到左右两边。</p>
<p>由于路径必然经过 $y=mid$ 这条直线，考虑记 $g1(i,j,k) = 1/0$ 表示 $(i,j)$ 能否走到 $(k,mid)$， $g2(i,j,k) = 1/0$ 表示 $(k,mid)$ 能否走到 $(i,j)$，</p>
<p>然后转移用 $bitset$ 优化一下就可以做到 $\mathrm{O(\dfrac {n^2m\log m}{\omega} + \dfrac {qn}{\omega})}$ 。</p>
<p>实现的时候 $(i,j)$ 的意义是反过来的（（</p>
<p>$\text{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> f ? -x : x;
}
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">500</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxq = <span class="hljs-number">6e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, ans[maxq]; <span class="hljs-type">char</span> c[maxn][maxn];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {
    <span class="hljs-type">int</span> xl, yl, xr, yr, id;
} qr[maxq], q0[maxq], q1[maxq];
<span class="hljs-type">int</span> ck[maxn];
bitset&lt;maxn&gt; g1[maxn][maxn], g2[maxn][maxn];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>{
    <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (l == r) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ck[i] = ck[i - <span class="hljs-number">1</span>] + (c[i][r] == <span class="hljs-string">'#'</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)
        <span class="hljs-keyword">if</span> (ck[qr[i].xr] == ck[qr[i].xl - <span class="hljs-number">1</span>]) ans[qr[i].id] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, c0 = <span class="hljs-number">0</span>, c1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) g1[j][i].<span class="hljs-built_in">reset</span>(), g2[j][i].<span class="hljs-built_in">reset</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {
            <span class="hljs-keyword">if</span> (i) g2[mid][i] |= g2[mid][i - <span class="hljs-number">1</span>];
            g2[mid][i].<span class="hljs-built_in">set</span>(i);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &lt;= r; j++) {
            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (i) g2[j][i] |= g2[j][i - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (j &gt; mid) g2[j][i] |= g2[j - <span class="hljs-number">1</span>][i];
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) {
        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {
            <span class="hljs-keyword">if</span> (i &lt; n) g1[mid][i] |= g1[mid][i + <span class="hljs-number">1</span>];
            g1[mid][i].<span class="hljs-built_in">set</span>(i);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &gt;= l; j--) {
            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (i &lt; n) g1[j][i] |= g1[j][i + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (j &lt; mid) g1[j][i] |= g1[j + <span class="hljs-number">1</span>][i];
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)
    <span class="hljs-keyword">if</span> (qr[i].yr &lt;= mid) q0[++c0] = qr[i];
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qr[i].yl &gt; mid) q1[++c1] = qr[i];
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// printf("%d %d %d\n", qr[i].id, g1[qr[i].yl][qr[i].xl].count(), g2[qr[i].yr][qr[i].xr].count());</span>
        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g1[qr[i].yl][qr[i].xl][j] ? 1 : 0); puts("");</span>
        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g2[qr[i].yr][qr[i].xr][j] ? 1 : 0); puts("");</span>
        <span class="hljs-keyword">if</span> ((g1[qr[i].yl][qr[i].xl] &amp; g2[qr[i].yr][qr[i].xr]).<span class="hljs-built_in">count</span>()) ans[qr[i].id] = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c0; i++) qr[L + i - <span class="hljs-number">1</span>] = q0[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c1; i++) qr[R - i + <span class="hljs-number">1</span>] = q1[i];
    <span class="hljs-built_in">solve</span>(l, mid, L, L + c0 - <span class="hljs-number">1</span>);
    <span class="hljs-built_in">solve</span>(mid + <span class="hljs-number">1</span>, r, R - c1 + <span class="hljs-number">1</span>, R);
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, c[i] + <span class="hljs-number">1</span>);
    <span class="hljs-type">int</span> q = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) {
        <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();
        qr[i].xl = x; qr[i].yl = y;
        x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();
        qr[i].xr = x; qr[i].yr = y;
        qr[i].id = i;
    }
    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, q);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) <span class="hljs-built_in">puts</span>(ans[i] ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>「雅礼集训 2018 Day7」A</title>
    <url>/2022/03/15/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day7%E3%80%8DA/</url>
    <content><![CDATA[<p><a href="https://loj.ac/p/6507">$\text{link}$</a></p>
<p>用线段树维护 $\text{And,Or,Min}$ 值，对于操作：</p>
<ul>
<li><p>$\text{And x}$，设当前点为 $u$，区间值分别为 $ta(u),to(u),tm(u)$：</p>
<ul>
<li><p>若 $x \And to(u) = to(u)$ ,则该操作对当前区间 $[l(u),r(u)]$ 的值无效；</p>
</li>
<li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p>
</li>
<li><p>否则直接暴力递归下去。</p>
</li>
</ul>
</li>
<li><p>$\text{Or x}$，类似的有：</p>
<ul>
<li><p>若 $ta(u) \And x = x$ ,则该操作对当前区间无效；</p>
</li>
<li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p>
</li>
<li><p>否则直接暴力递归下去。</p>
</li>
</ul>
</li>
</ul>
<p>分析一下时间复杂度：每次暴力递归下去都会使得当前区间内所有数的某一位相同，每个区间不同位的总数为 $\mathrm{O(n\log n\log 值域)}$，时间复杂度即为 $\mathrm{O(n\log n\log 值域)}$ 。</p>
<p>$\text{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> f ? -x : x;
}
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, q, a[maxn];
<span class="hljs-keyword">namespace</span> _Smt {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> a, o, m, tg1, tg2;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a &amp;= x; o &amp;= x; m &amp;= x; tg1 = ~tg1 ? tg1 &amp; x : x; tg2 &amp;= x;}
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a |= x; o |= x; m |= x; tg2 |= x; tg1 = ~tg1 ? tg1 ^ (tg1 &amp; x) : tg1;}
    } t[maxn &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        t[u].a = t[ls].a &amp; t[rs].a;
        t[u].o = t[ls].o | t[rs].o;
        t[u].m = <span class="hljs-built_in">min</span>(t[ls].m, t[rs].m);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        <span class="hljs-keyword">if</span> (~t[u].tg1) t[ls].<span class="hljs-built_in">aladd</span>(t[u].tg1), t[rs].<span class="hljs-built_in">aladd</span>(t[u].tg1);
        <span class="hljs-keyword">if</span> (t[u].tg2) t[ls].<span class="hljs-built_in">oladd</span>(t[u].tg2), t[rs].<span class="hljs-built_in">oladd</span>(t[u].tg2);
        t[u].tg1 = <span class="hljs-number">-1</span>; t[u].tg2 = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
        t[u].tg1 = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span> (l == r) {
            t[u].a = t[u].o = t[u].m = a[l];
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(ls, l, mid);
        <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);
        <span class="hljs-built_in">up</span>(u);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">if</span> ((z &amp; t[u].o) == t[u].o) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {
            <span class="hljs-keyword">if</span> (l == r) {
                t[u].<span class="hljs-built_in">aladd</span>(z);
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {
                t[u].<span class="hljs-built_in">aladd</span>(z);
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(ls, l, mid, x, y, z);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf1</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);
        <span class="hljs-built_in">up</span>(u);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">if</span> ((t[u].a &amp; z) == z) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {
            <span class="hljs-keyword">if</span> (l == r) {
                t[u].<span class="hljs-built_in">oladd</span>(z);
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {
                t[u].<span class="hljs-built_in">oladd</span>(z);
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);
        <span class="hljs-built_in">up</span>(u);
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u].m;
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);
        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));
    }
}
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
    <span class="hljs-keyword">while</span> (q--) {
        <span class="hljs-type">int</span> opt, l, r, x;
        opt = <span class="hljs-built_in">read</span>(); l = <span class="hljs-built_in">read</span>(); r = <span class="hljs-built_in">read</span>();
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) {
            x = <span class="hljs-built_in">read</span>();
            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);
        }
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {
            x = <span class="hljs-built_in">read</span>();
            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);
        }
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r));
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>势能分析</tag>
      </tags>
  </entry>
</search>
