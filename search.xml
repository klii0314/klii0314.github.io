<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GDOI2022退役记</title>
    <url>/2022/04/06/GDOI2022%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>晚上跟随大部队来到考点附近的酒店，和 $AGC$ 分到了一间房，他还是那么的亲切。</p>
<p>传统艺能出去吃 $M$ 记，吃完回去 $AGC$ 教育了一下我，说考前不能吃东西，否则第二天会宝玲，我没试过，应该是假的。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>开考后看了看 $3$ 题题面，发现都没有想法，自知今天是 $div.1$ ，便开始想暴力。花了大概 $3h$ 将三题的暴力都写了，期望得分 $1+1+1=3$，想了想进队无望了，于是直接开摆。</p>
<p>最后 $10mins$ 突然发现 $3$ 题都是傻逼题！！1</p>
<p>我赶紧 $rush$ ，但是显然失败了，如果再给我一分钟我就能赛后一分钟切了。</p>
<p>出考场，身边的人都在吐槽傻逼题，但是都没调出来，导致暴力分都没。</p>
<p>我觉得还有救。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>昨晚摸太晚了，导致今天只睡了 $1h$ 不到，有点小困。</p>
<p>开题，发现三个傻逼题，怎么今天是普及场！！1</p>
<p>正序开题，仔细想想 $T1$，发现有点难写，可恶，《摆了摆了。》</p>
<p>然后发现 $T2,T3$ 都难写，为什么出这种勾巴题？？写了三个暴力就补觉去了，免得被 $d$ “怎么摆烂啊？”。</p>
<p>出考场发现题目又被喷力，好！！1</p>
<p>我还是太菜了。</p>
<h1 id="Day-n"><a href="#Day-n" class="headerlink" title="Day n"></a>Day n</h1><p>$ccf$ 出分了，实际得分 $1+1+1+99+99+99=300,\text{GD rk 114}$ ，不多不少，$\text{AFO}$。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
  </entry>
  <entry>
    <title>联合省选2022前的记录</title>
    <url>/2022/03/11/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892022%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8bc4edb00f04bcb8e4d5c09aa82fc9a710344bbc1066bf7511e3841e02e9d461">cd67862bdd141bb2aa1c78ab2fd399f67a60072de8008dd25d832ed6a25ec958c271597d94c64ba64b861d786834b124f3413b301a1947fc82287715bebaf983742e692ce9848f3d0d1dfab8866ef260cfc0c83ac68307510cdf749504ced4074513ad1af2456e331325330a9dcf0a99f73f8e490164b28d0a7feeb26a236484e3e3d31d6319911656f7f53ee48186778026b3ddcdc661a5eef952f66f3c023377502e6293f1ad0bb3b102727c543cc7a5a04b2a59a265f1953762a6271a99b90146287e7165240c431808f414d7c5bd827393e4eb9f15bf8bdf197e29b94267a56a1a841f939fa3b90044a695cd54eeff3c6e50de2aa74eb34b4fd1765736e55eeaac1e48f3b2a68c1340a721606decd93f6b96d75c43c3fe5c8a7c81155e08280455d581a111180e65048c5aeb15cd39351e0d52b6093fddcea44a3dee24a43d3dc18f4c7610de39ca0cbfadbcecf66ce1e58cef75396a82e8b59977d237f718fc49dcbe744847c0e1fa22755c15a81a4e790d6ae350d3643945f201286254ec974e5acbb38952b71e93a5b42d429ae6e18b9334ff3f59dbf7e7a1120d7291fb0720b42d4cec1d416f56f1c8e861df354275eab09680cbedc0c5c800900ced2f8f19873d58d61d1a06334878ebb30247072c5a71a33f414a35af177eec77fdd8488750c29dcdafe0d097522ce1c9908a1d9772d53e0be4b8f0aa919b308472c613ef344cdae554bd17fc2c97693e505bf5a4cbaf892eb8e3ead74cf1264bdb0f4d4aa091cc0773d58a0fb5cb02ac7dbd334b46e9ff542e87cdb08a29405c82910652282240b76bc570463db43410d8383eda91929a00f404adaf8d3c49f31f2917c47bd71710c9660cd4ec980facaba6c930154746e36884368c39fead3dfd8375df1a84396aacd5c9496e4d6790dc5d3c12db970a15c72d46079d0df973c09577802aa24ba2b937c7e43bf666c079c7db0c3dc42e59b6534bb31dfffc3ed9be4ca68366f19daf9bcca293e7d47dfc1ed0dcdc77bf0208d93aacc53001e21064b873a9c931ce169d6160bc4dfdc7f128d83e0278be3dee7a0f10b0a943b496b5f589b33219a74f29800e76b56731886cfb154ef5f76e5329b275d2d13be4f4910227aaa1f9c85d7539f558c77a8c6fd934c9a5c2abfe640819af19a6403321399534d43b6f5ca524b5b977ea2b46e644041aa3a0e0faf6256fb82b39d25687dc11abf2ed3ed0bb678f1f14ae504a9f13ae4d1c53d0fb67942fe0037347457bfc7a9040859ca454f749a1389a195436c0528b09720748ebbb0e153d074ed27347e985ea770a1f4a9e7f06ad0c16e21ec96c9f82f50122043797e142563b105ce3cb319488d487649a338d9fcb9adef8e910d57b43b1edc66844fbdc7d98daaf52387206a3f9a942919d59d80bf8e483b944d63836168d63ad7a2e154ee08ec2468b5cea6fd42c4a087f39813241ac6714b7edd1364367f393daf98cf0023374b53c3957987b123afcd27e5372fb558b1de36d2338fc71e7c9ca15da190fef87af03b52226b8774d7d98a28e9d6f2d371c0cc1fdcb237e958d532e570dc80cd8e15c9d2a9306c5ac632dd5af1133a3e0df83c55155266252b85f4e95752af161b56eb7c01b821ae3d8dab86fb18c29561c1f72d9cbd5c2a3f2ac1d428534a83f4f08679583eaebf19a0b5c6e7f14a2d4d74f9209aed93e17fcada948eb3a7c17e803f243b4d79a82eb1a7ed3dae05e6f78766c3cc83fed40b2d9ad54bbda29fee0d72e25367c145da4fef15847abde3791f6dcac530638b5d7671db77a83e474f72ce5ddd2a0d46b95cacfe93fd1f788283fa4187cc7cb05ff5999f8084f99d8121e974044c4d2d5808be6f5aeef9fe6bc017fd4bf4c36ab134a79a928108e1d8af29823ce1b8bba654003007132fd295e885d2ac87ed91d1067f867f11f02a5639e14604695240b1b632455e93ea5c12e71a38dc47b93cdf7d9dd681174ecab3df7ef67d0551fbf20f9ef6c98a04c8499115116c7513d24bcc5390e2c95030192dc4cb79bc2851032cb0515c089d2d82b28395ef3dc553435e16c68dc268bbaa639ed2dfece4b467782bbb27fad712a647ed2f3d502f17ff79325735a274be4e390183d6018b0adb2526ea4fad5044f3c8dda139de3eb34768878ee0def121ddb1fb1ac1f3cdaed78cc1817ca72d159dbec8283e7cde91350e563c921b08b8307d8485d27ccbbfdee69f8b99ebce21f724de09891186c8d9b82a1dee112f3464b76a6c68b94f2ef5eca9b9874c675b9b08ceb3ec707b0e0ac3bb5c93c9b327b1cede80e18545facc3a9c071d761349f854c83facacc464f03666a2f89247e63326c9d3b7ace23588e67fae8a162e7d5fbb0ec268ce2c014537f8567df6fe675ae16193b11694dd51b4b759ee3689a094b127f431cc35f75d36aab1bb39819a5b293693122bc0efebd20a02f6524e17444d4b43432ae5f73ef1fed14f111e6f5eb40c8bfe056e998a675ef2a0676e236421120b8dd35989111af06bfa275712c5e6e1ddf8869b4e53d87dd2b22c4ce385a4131517a6c9fe0c57039de91a891ea07b7cefe21c1920a741ba95d9e727bc67c07234eff3e40b151838d36055287570f6dd0d27ab04098554ce097d2b13f4066a105bc114017001160e123f8ef2cafa32cd59a0fc8af517b4c32dd926a02cc53b9dbd85eda1bc337b7828857357943c72dab5c8ea94368d7af5f45da37125689b8aa28621935f85f7bc15ae0042bbc914ae50d2d27e27a8a036bef5ae28689ec9f04746fe358224b55e07aa5c43f39ab2263bc9af97758fa000d3ed35a5f9f716a5853acdca910f11f0bbbadc3a74dacf4ca3511df660bfb53fb20da4b6c001e44822ce6c984383f9585d06e161fc63708a474cfe5bb7a71ba3b929898572d7110200c7c5525225b922d7603a9826626fc15d9981c4852a792b392ae5eb92e3236353b2e8c9d88c38206a44df82f9d2e6cd75abd5121fed4dd8f00fb1b7f5c805010395f17909a9a60bcf87c8b580422d66f4f46c792e24ca562627078443d1b96cf7eb539a251c2cee10b40eba1faf51acce17a312bf4222d6e403f57df4aaca9d2940751aede455c2c78a224a6130c33efb5ba99b9fe88a7f2ca1ee6a87becc2e5dfe80224c32822d6525d85b9d4865a85c6b21fef5530ed5149756dfcfda84c1e63b309165aad6d3cdf91fc66122aab67065b6e5d358aa1d22940d99ea2c15473151f267f697c4167cbe96e8049cb66fd71d431af035cb28bbe43034030bb772b2cb9b7ffc1037276c3f6cc03c5d05196476064219be89ccec894671b25b2cb8744dff3eab78c6468ecf0cc4c55322415f7315c7293863fd507269576365aad74c9f7aeda7f81b858ebed28673d41c92da8cff34271bcc6d79cb4feafeb27402e7bbbf20144df873841ddf6efb5f58aaaadd9f4f4444b15d6ccac0fd9c9a039ec623908da7fd1372ec9b9ff30533bab9651aa55b932ed2c1e10cf859daffdaa7bafdb439612b7fd8a303fea9f978c096342a024c8c1764b26da924594fd934374d5a90ff1cced5dd143dfc20afc889708010f46391d6eb96a7cf59ffa1ffb268771219e9f8b7d9a5348770cb4049fa744fc98bf8f0d612a6191ac8f5d6fd3dae7e4b199f9121de707ddc1d46cb0998934b491f4fb79fe337098564ecdb7f906e09e89a22f99feab3a63d8984105d740d77460a6e59eda65eb22eb4ac2bd26b18f827708297a250d88e92ee57b778b9f4669816a9b4ea69cc85dd141c6291d3727da12ef17491d90bed5e01789bf12a58a8142acecacf56b34cdf914c414c7131e186bbe237feb58b50f91383b11e8dbc6eb80e89150cbdcbb4ef217b62496b64fdb819c0df051a57ce7f9b1f97a934e5baef7bb1e195c7ed071822c3e849a51470cef88a68d9717d2088cc8cf1b9d6789dd353fe877d3f2cf7777fd46040640ba4545719ed7fd2284990e0811a76d99715f9748d72e467510f99999b695470ec74cf9c0fd8a743feb5fe9f5d5274556612f8e67ff1115fff47f702103977614c09d6a88091bf3b2874ebf48196a4ee8a39771390c17b153309d58e41c8d7445ae6a26cda84e8a725eab595e75b8a537b4b51ad1f4d4b5142a0790f38d2bf1a508e6940f332e7775786ae085d0239819a6663f99fb5306ab4eda164d7dbc70858bb10f8785152804d11abe1420376012508db04c1f4729b1d7e60bb71e4c6a50368b92c1e7df332b1f90ad81c85b871e366aff385e126dc15e051002b127bce62902efab9f3a8d18f9898b594cd89ac32bd1ec1926ab19715d96657b75bb7748b7c62dac6379d31f9c4298b681f01d7a647c9f6de76dfde5441faa5cb4f4962758dda5e298d68e064c664e4f4077e01dd40b49141e82e2eff7c04e635dc610870fd0a0e22c3e02fb1fe9d34b0cc4cd2330900450bf8a5881aab2d97f277e5b1a80e55e41032419671c23e494e74827b0ad788ef1bf7273f917a4137ccdff62c181c355f1ce5989986d809435d13e39be9e3380fe65f9b5bf209f421b5ef24a4566ff1e24e1720c6901e6a941e22763ecfd738d8ff9ba73b5ed0ef4aa49994041d96230ef4fc6d03d9f86c79dc5fa9d73d33430e4ce5bb714f2baa88747daab37f5e2b93c83beccfc6a99118fe4c773493088ea98844d1f8af5ec686fb502bbdd7d4d03d4838aca733ddb3d962406396ef4f13a258fa4f4a63e14ae52d4b1dd3f40e6fc7d1c37e73f98beaa71e174ca21b35bdbc566f794f5d5160da34b837edabc0212a6c68f4b22a38f5694d7bc1eb16f45bece080f8dea3165702fa4d0ebb7b0f07ca21233a5dd6c7682b6ad83b24a7c32a247fe6c762b63386ef63a2840eb7b7fb7f5c1a9b9d6288dd50dfd540f65f5b141059b0396a4d1d6330a1b84968037a4ee93d35e44ed39882d969099580d8961f5911a24dc5744c2c4826aa6040d67923b778f06cf285442f6385d38cb4fc8cbdd98a50a1ad05e1b40be827ba10ecd5f6fe03d9d2e7047cdb6ade3675713c0049001cbd451c9b69703ebb4236d431014da0f44ce379024b4034d278cda42e5143e9c8a4c5ca5a9e18463e6a4c28cd049bfdda9e2d2a5dd795b36a081a3557c232fb2df5f1cc51bc45fa110c4fc17dd7da57f0849e6ed2d33a299272d566265ee77b052acd79e4407469d1e8e167501f520af90e0081b305b9d8663577eeaf789f608642b5dc67c59dd02d675aa0749a68cb3268ad704078ff03b72ab1056002dc13089d8148da2a109feb4b75e38fd9cef9526f38dc58d85b843799da645196c82b44c83ab611a652d18410208aee39680c6db3ee0513bcfbad0a43990c44c6da19889aeab0b15f034390a528786900e3da7669ac9a6033868d645bde58b82778ec49d9235837603d64c9fff5439b7753f536b190b038b17d39c8d5b483a99a149e6b35a3ee15a87d74c6acc585215da69b81215ed114e8983fb8bd0d259f914ea152119ee9c033d5fb6b2efc4eff521acfa9bb43f7aa3f197662b48b586eb883d3bd6920cc21425e0cce1805ebb2af326d784494e0b30c2cb4bf2bf305ec5d817eb7584bf4fb2d39d67489587a5b3c84cc288215022949ae117a73803183ff5db016d3d862afee6a533b46f19d78d3182b8bc03f64e3b43cd63d4ce514151cfaff315baf9b639643890fb4c2f04c068308c3d9d4280ac52ae2b800f3bc94816cfea7f4382a5a9b7c52fab51ff71032d23a7331ac39a3ea5681e40f2eada4a3219ee459976aac9038a1dadd2f3e19105d7701035ee1c73aab50714b27d8bf21fcd54be7497fc43f02eaa2b95824254c7517d40d7ea8933336201bd2c7e6eb16430dda6e2fb5c9a3cde3c3eade5c6ebafb4a1dc423cae1266198fd61046aca037edc7121324e68eb9b7470b3030297ae0e3a34ebcc777c096460fbe3a77980cac97f7b3927bfe326bf2ba34be3d8eadc865e8f47d0043a57edf3ca82e8e299fa40607d301cd96ad35b743bbc6cf1e6e58e65e03918e4ac2bbfe59b38582d198a1fa208726d307601f04dc745093c747b4b6204ae193487d27b6dba9d695c86ac3bfd3e93692478982547c7d8d58610a80ef31fbbfde19055851cee40107dcff8b8530e0ec1f96aa0c42b6391bb1e287febb2dbfdfb466f510a01ea4bb02f56ebcdce61d1efa17bdddcb048d3fa8310b6adf5f43cf481457af419cbf2dbcfa07699166721cf574c5a95d43165e9c5454dea2e7a0f30d2b3ed544d01b61a97d1a7d08b1b1b71925a7076ef866c5b6460c7d7298813279faf231100330800d293225bb26cfd3d79c296c36f7a706593de871c5ad334bf60ead254b3cd374a54de116107cdfb13726e1a3729a21d6e0235494524edb28449a5a05f672ec2d7dbb09dccbe8860735e60948a9be5e2bd444b6fe178b4b38bfbe506a3707fc5d4f20bf4d45926a4d17b3921a33c1f445ad9558e6ffa9fc5f7b6e26ee8f960ce4ffd1a317f5703e6f0369ced14b4b26875a6b43f397b168f2dfc7d1a9df0cda7ccc4978a77953a5253eac4fdaa5042eefdd68913b1f7eaa52d1930ca5b693c0571a8c68c4757fb821e426e3e99aa29ca5dbfd4e701feeaaebf62b4d70efb2d97d763609718f2ee4f3baafe5a78da0179700e2d8ce65f2893bfa9e542e35fa1ac233c17550ec556dbb7caa9fbe56a44661def0786483418252fa3a8f5fea03e75732293e4e9bddd1a89ad8598f6cdcf891a80bd1a737d0908205f8210079e331b344a044d7f48f2aea4de275335a2e4196f63a60688f4c176c57a410ab1870a195fcd87f91c6067c70d66e12935b27ffc8a5015f6ed72a15a2ceaf4eaa1073b480736af2f25a0e34096ac4e1401ab86baea85c20acee31df0360a9543201fe027331a91fdbc18b3d8b228f49934ad3be6324abe76526fc2e51f9c43bf3097d6ffa51c54bebf19e38cd48975c5c0a28648ed3d9e9b9e15d5d6fa3e2865e184f6dd02ad8daa516ca0a5fcd88e43bc9fc1d54d7152fafa3eaaf19b79585a1997d19c4a44cea68810c05a8f2f352b489d7479948cfbbd309f49177c276d3bacb6cf25e9d5621f86a7d1656d14ef4499545b6881e73597f3a3755a5818cd6490e52dc8e6663ce94f91dd6211d8e53fad9d91d18768634db1fa5c5008a38b314d314377ad1fb16d0fdae16d5991f0e658125b3e5141265640976fa6b16bcfde42eca891dcfeec5c1162fdad34018ecf8b0498cc248f90b72e31708a7d9dc1753e0b9860f0c3ef3b00b969f313c8cb5dfb4d8dcb0756d1e2166e9346a8224fc3c75d15af8c1681a93934fdedfd0b47c13c4acf8782edc2e1f75df03fc13390e082635fcd283e4b61e46a8dadb15e704726e07a3dcf018d80e3321b092098be06b4015570feef0018b752d3abadace2747a35b92f197bc760bd6817a9897ee39fe4d879aa7468b5d62d509643e689e66c21a63946961a81854c99e5f7a161039b8ed14334c8e1a697b6f9d86c9977a05101dfe7d10bf3b7393a412185112cd08fc345122a187feaf4496da796c5a5241014b147fa2f5774b77d68f4633083d4b1d8cf1915ef4f442b8c6174af931ba81e1b95295ebb48e7295bbcd5c2258039a0cee9f0a8aebf1528dfea42c0c7b88efa32955697457a42b673e1925d115eb2e76904ef74e924b37a1f6ab71fc7ab3bf07c47c2725076ce05fb7cb1b55a053d23dc5698cc5287361bd5b1dedfa20b56651646a01544a46f1f2cba8523f1c91a7da28ae455d3de9d4dd81a1a4c58c95e279f0c0fcbf98a75fe557a61636989f93b54a15681919367045c81fc433ba78bb9ceb72bf3ac218aadf56620fcc7d09c23612a56f41105aa5835f893ae8f41e1997edea42aeab761ce5a43d9b655bd8d5fa61ca158af8e6940c3f6b4695bc59e7c3676bf0cea811333b691207f0b9059382e6c0cbf99f958512a93111fd81a54b810d28650f0fae05fb9233f21171b00a751388e0b2f372b24f1d2f56b155ae3490f03d048005c2ba9437fba6adc6b76daef711ee7b0148cfe87b8c67a64b5aa2eb19bef55286318fa03ccef91a899e1dbee2209e93b31bd63540df28d24cbdf58c6fde5f5ab780a35d10b95b26fe26b50eb6fc81720c177a7f69182da32007e787828a63f337e6d8d9a5f3a4c5c95cb39b4b270537f1e8c9e3f5207c0cfc561aed32a88bcc914577fa028395c5f30a0ddc9f247769d04abbf6eb74fa054ec44e2f2eddceaceab0995592f9f637da66a1983b4fb9a0a459753ac06dc9fbf7afa48ad32b1b8220991661ddb9b3a70531a74270671f1973857ca8b1acdd32ed0c54b4ffb2b65f2931b389902e7235d2f7081337cf06152ebc8b043c2ff3a336cfb54bf670ae7d2a1378097dcbdf2eca5185ad83e06bf59464919658ccaf6738679c2177a5e888186081829380ac9f9ac7143eb2afc6ce359f801c7d286f5143eb8bf08bdc4654f95d23d5baed110b518491be367f3511d8323ee96b0c77c006ae8ebc7f3aa3a7321092d421d2e2d1f4dbc8a11fcc34b6a295759974225fc7ffc1c5128e4aeb40a0e96ad6cfd07332d069ac3b406ada5aabd124ec865389dc1d1b982e06a206a18e8ccaa26cb3c89ac77c1bbb36818f9ad283a9a816623d056eba97c08444c1ca817e91fedf4b04f89333fab03b16b0eefdd325b29d6f189b0b5ecd0b49895829868908800e8ea3a2b5b72454f734533ddaa4c4ddfb9eef6e2cbd23e5ca0405f347b1888e24781da1d7bf7eedeca24035c19ca3ee54e9b25c2b83d5b0737276644842e32d5257425f3bdcbcb20503df0afeaac7e21e96aa005b0c68c6802e9a6f636139dcfc0d9fb96a20739d34108583a2fbfc09b97cf29b44a136b5f0201f92941eb78a82b87cf06234e3e18b3ac1df56efb03b368704ecdc243d6a9ef28ec9a09f64b8aee504f2bc0d126f0b50e6e9878cf52e812d19f557f9977223bf392eb2db570bbb44bd9b09a08bde6546634ef28e125c67390f8f0a9ebe2fb61c284968a57ec3f88a9dc2f826f865ccba639d41a2349f74ec479825594f5f8af28d45abf2a94329791c30456706e8a0b1288bdf8b2e089fc7cac780868244e49a975a54cc8711b08bc4f966f82b70d9c61cdd0865359f072360ba7874ae4f159290ed87f6cec676ed002ab17248dd80ce140164f40a1dbeae721aea9a62c99fcc141038dc21f3715c7cc262ddbce305c77f27c49a02324fef7892590794498a5eede8f8640ede718e4f7a9a4d52b219d9900ca0ab229050f8c8d83aa6a3b4303d4a855301d31b211fa6f9d5c458f6fb19cece68fee7587ee6458ba97bf3f1a5ce3156d4c27c7a1bb7dbc711639d7c603ab5590c8b73a3d4e850cda3fdafd8b94c19e08089eb76b6490f6227a15c7ae0acb81e3dff36d6a3c133bbae3185c5033fc7acc2382ff11d3a2831198a0fc06fc2d56a7f20bf686ecb8c75c44fe2e0a3959c803b32683ae60243c5d18b3cae6a460eef3f0286c0fd69342d627340fba4dd65335dcb26d9f13d98d6de583f5b6694fe7dd772893489fb786362eac3bbc6af860ec519bde9321e7f0a804e7822a6dc69e5d3450b2b6c64fb057c1fac43bf4ba3848b648564086eee7d484c5c52d31597eb5c22bcaf00288c77d6e01930db5bf6101bf39f95720f6649c60d003d723eb3c155ddc532e1eda91d307c51282e5825b485c2ca0bf8393b5e4904bda18b52ab2240ade9cfbedb270755d96c7cd0aa849b8cc0836cac4f2b2dd131f5901a4a3945f2736500d4957f2fa4a2f99b13c40009afe7920531992c30b9a0a30b1b6ea66f7e4728c6a5438b9748db69c4c1f9302ecaf6c529c58b58a76a9f5d72891c54091edaa9752755748517d8bb346202ea0436820fed988178ff1e92c96ae4fef7ed283c8c15b22bafdfd4c60e8a14f74e4e8af7d2488ee8e4adf031d0b388ffff029e1e0c0284ca030b8553c2d32214d8ac221b0ef509d9a8e760aba8f8b8354893d71b5531b6bb6ea1dee52da9419be7ae6133ffc72730a3a7932c83d5970ae6797b110e29a44949106c0e9ede0d87706f324f2e6c1e3d31c1295907d4b84b868bf8272aa6bac6798447b6730a492819ec56a7768d898265c0264b4b0b9752acc509de73ef2b7dc5b048c5adb1289c39a426ef6c01d4fbc2efc3637d7095fab77c9c3ebe36c6757dea0965dc1871846aed62696406f32ff4a178f60c255be197cdcd7d47809a5b3ad246a303419e789fc42c68f6a8111f4d06cd405fddd48c77a4d121f3c29934c974532b3d2ec10fcbc098822d895b08e4e58809351e7fc75b5fbcf0340db5253bad9dd38dea412af4b60bb4d8a7536c8ce4a9a004a4a879fe40f8c9043c974c671c861143c1e5a23b8f7952a27d72c02941cb5a5103217f13a3e8228dd6ef7ba59f8f17e52280217871502af6b050e60afe220c11c1f070a5a6d75425dd39ef92ed9eb133f9ba70c8246465a42093f46707810e2666053bdd68fabb23fbaf696a42f04d18db31dbb59afa76b35a5d565b217ab53f5b91b32d059b669613180044f28517e188de6d92f19f3405b38338b6c8ac102b23148ccbcf967c1aa8bef8ca0eedfc0828fbc27b60b4756e02f754ea1fa82b32d05ba1b40feee2da4f188198ed0ab2acd1c93e161ba184e701695cd32784f726c3b4295011ec50b1bba2cf75be75e6c168c63cfae230e59702ea7b1ef6cdfd0d5157b079527c5a771df88f608073f76c0aefae3821d4f39c344ee6ccb42a2d6fcf237338adc9610fee46f9a2a0034766c92bfcdaac9a91a7a5e5bd8426284856265d282f1cd87f45ad1b446642b2fbc9f9806f4bbe52795940e5fee41303ea8835366a592c8223b8a5c5659b921009f40ff20e104bdd7cd0bcb813b497ea71aa46bd7aac8655ead68ec0613be8ffce12269e86e91b8f647a91b3c40522f26580b6666e4b9f7e09e9bb612a6b2752eafc8ddb0c2c3a81d47df1b2d71c85934738f0cc7dbe78cad54138da2ec83b0d3df8816588784633f5dc1b91a887deb57a3a3b2562d6dea83f7eec7794cce4e2947cd319e683a193d9c99e708591d8c4abbbc4d86e338734c66a1dc77f7216987e8699d080833c98bf09f57aed9fd72a46aa1f8f671b70565fb25d840193d0d59d34ebf4816d72a72bb4149bb6d8b5100558d3d672cfba3df0290f3a8375b48089f29329c4f7e42074d3dce63b0a39011439dbc60840987aa6e5cc32a8fe56b185830ecca9138438869449e67a6e820f1d3e4d8dcc9e631e27546531f72aa15591f33609ce9e5ccdcb1caeb60ee54077f074b9a2576e5a9f0f474b966a3fab61ab6dcfb4a566cb28ef8d0e963d39b267068a174a5c307b403671c31307db9f3085e9890763ff2411d91ef387c1bf30066b2e0b95b430af0f65bf8eabc22138bc8383b54741fa495faa4e121b85a052f72002bc49980f0554159cb9084391f0c1319e181d37f5174e7663db24da9ed2519c772f6918d0d233033cdcaa52d6a26adba2f1c148e34211da42cf7412298f94e951c65a3d0edfdec0a46d5baec3929e7d67847dddd4922b7ea7f2068a82b948b3af69ff33056744fe82cdf5d3ae0d78b87d1a1856b4c635da97e18609e18593150a708b21819a83404ea2794500e22251579a2b8ae286ce7d44f0b59ed32daf8b9f1412e7cfae8189f91194db8b66537952bbaf7551d8cfc54430b4f93df3b40bed24b7a6ea4976c24f3b83ffb7a4016ec9ba8475fd62cb0aa7fd8445606bc699616f19c2277563dced23381525b7e44410ba2be871964c02d3531f85dba2664ad8d6948e8c46c369bbc8360c968c616bcd9e60c3cbc184bfdbc09235ccebaab6c29ef6b3db0c057eb6a3d5f7670cee874eb70bab59678f8a8a03f6679b03178b038f80f3bdcf5cfe5aa7a5d69e18d1fe8ad5d78a19479e02d2363774759f39dd5c90432377a3bf8d2b584c89b72dcb5015a00f94f6589bf114886efdb7a6d400b75ae93c8b089133a6968ef4f74193209ae67b3d14794ee0cc4176e945b06968d36fe5328f8936d2c036f99c2f27eb827f0044cfb0824fd6448a8214942082d89ea4261f148b7b24aa434b1f572704e6acf21f623ec70b276396060ed6f12106df465fbcf617cbd77056a84c7f43d3268e024c726734d06c8d0d2a372aad741e67b87280ba4a4163fd9081dfbbe41400ac93e190298b612072296bb9a3d7bfb69a154f98a0646277dc040bcb62b97af346f27752ce28564c910c7a35cb45fae0cbdcebc0635ba62f883b8451499cbf841030a734208af9435e75570b4fe9e5514fa59d9ee097eb5b365ead93bd99c73a5bbb7f8bd5ccbc3be4e4663ec77de196f8a2574bd0ed80dc1158a2ced7d8905a1c29c29408a065af5d12b0e286179f3cb2f64d017e81ada8e1045a746873bab496dfbdab70fa5f6cb8266115db3b4c064f948d0afb90deee033377f171216a9216bc7cfcc8103414822529af477c89cc884a18566fcd49827b6182ee3d6a7aee2d72060e61c958111fcb7b5290c1ff7fa43809706e8f51d88b7d88d03655dd3449a05115a18c2aa24c9aa7078933bcb3dfecd1a152db6d36371ee22f9ba9b19f9d9514cd009ee5c32ad75e3e0f8aad5b6de96819663ec376353e881fbf1f1a495d4027009e14c1709eb9b009ad29b1707a223f8a81dd077b0624c7ba40f895c40260cd0c912ccea9369812508f8aa7eb32f9170d24a59cf560ce0ee97fd83c309d2c8dad748e6cf4456ae4ff8ac10b9b36508297a9dc570995837a5e6c89c882b544345f098a66573c3173c90f5404b92702666141ffcbb011195201c7c728a743bb1f31d6534390fc65526c9da52fa2d5a1b2ae614c02446260d8a4bf7e3ff1cf9753ef28846978913649398942ce73dd2312d2aa11de8a5a15162bbb6c410a7c4432375fed24132defcbfc32b88ae1202bb2df54e086101ec208846f63b25961a9d5689b650a3f618ca3eb4c38bd16a2900ea977f90adf96f35121c0c6511ddcfddde8ec0db92955731fa7d55965c3a75f868a6f486819f4093d19fd3180211a89217d4c75513f2b8c24019eca2c528b8130c8c2a01fe24be388c3bb3b25f4b10407307039a9bde61f07fee2201541c44a1313b98407e05f640a2393e22162554642ca18ab62e7fc123123bf3848360e284e5791a821ff673549d14a93bac2d6e8e2e611616fa66da90f96277b59f672485c88bae86ce9de414b3b561c92a5ef199794b7b73c9ead6d6288f0ed0e084113623b2448c96e5193ea046f42a0123358ae7ed5705dfbd5c1ae47c06e823bba3d020e241054f29fb2dc8d6cd6c97a5fca7b6a682ae92e895d034cbf2677b2059183b8b37cd91a3e2aea719b0a74d634dc6baa643ece29a64200a6d475912bf74ba41413c7b442dd03053cf6d91134c8e7a303bc571de85763857f72488f9bc1c33714f9645fdc5a31c884a83e4679186e175e3d57f6c4364428c3fdb2d0e774fae1f5326e3873823104cbfa791206a5e70775998d13f1309f38540b8ef9b91d3e9abded5c80a42345ce5070145961cb405cd94288260c936ed172159b90d3369cb918de7faf5881eb5ee64b67c7ff6f2d56c1652345a28e4caff43fd705a0e50ee95baf415a017acc94ddbdf616698adfe090aabf242fc395d046b8c5d3e092e91dc349c61d9eff92d8dc00b6882240c581d0a2ba458637b01e0bfcb78711e8213c8498aef788dceba90e4dd09fff85e76b8dc2313b94477efb6e41e495ff96f11992321a3a4657321e748f27973f908afccaa6050dbe5a9c5fb38960912b8b155395b13c54145850bb76ad2e35b5d2328b0d96ac52d317f9dae1df78e03749663b24f9b072d38dc42c41bf093a06bd1e15dbee3c0a3dc92762fcfbf68fadb1b781eced08ff19874f7df4f40d55ab5a38f72368ab063f77888fabc4230a95c49cbb936644678d7831e0b2ca42983816e202d492b0b6f22a17bb0c017c6c18141c638eaaee3fd406eb5193478691cb30511c47313a79e00d634e7e204776548e13d84e907c25818546d7d664bc973a7c0e8c0138bfa57886b1c65d372879cca9d896e78a32d0b3ad56853fa4fe185298766a50cc1e4ede862c9ef6ca034b3c8c08f4cf0030b32f121f4aec43afabbcf1e048e0b6b71a4bd8d683ca7dffee032ec12a33afb26dc3eb0ad14d4a630f61b324a2ba5b4bd92f6f4cac3996411b55dbb6896c4eb7096caddc32017b3be9edb912d55c26b1355e8e5bdf754a64e1429e778901d502f9909b080b16a54dcddef636a767140709bf7d0865ae335adc95086e7feae78f763cb74a1ec8f30f784f4bb9cfe9151991d5fbc580c2d2bec0cddf2ac64224c39ae00f845c4ea2c8b4a80954e2b443cfc8edbada446868d9b01bd5d9d33308a846338488df3acd2bdc10102c9521aea829e23cb8139dc1194c25348eb73c45a7b0cbc59bf06cd7292850936daee5596b118f2726a65fd7f6f0cce64d246468d63c543121f9e622c68b94fa0603cf75b4da3eaafd6f415f55313380ba4e5598e0a9c6b6b63f326ecf563956bb38f21d7139018102ffd0f7122c26672bd396e919a1e40da8d4f6f51365739ea3088a42fb55e3950bf8d018a94fc9ee8ba7115f98fc93382db19a609885caa36a28a2964aebb32be8fdd81603cd399dd6c91f875088cd7be2cca0048f9f5b2633f53df624d80a0815c51d9c1eda2a8a40de87c0a1ed71de0749f0783ac212b951b52431c11cbe58f4b29ae5093a8824a9dd0b92839182a5cdc666e4d2b5411de740c5bad68270f3694e3591726a2e79771e6ac1c881967239b5881b5e0d697d8920e6348327e2b60835c2622d7fb32d99e742f7029c69c41909557c1777d96337420d4e47a1c9df282a845eddf3135cda47a8e6c92468cd3cef5778988ca506694debd8a5341459b1d20f52203a55cefdd5286d69259dc04070e2eaa468ec69268b5e88a140919508a3da1e1572a1055648df90eb6fb6caaa7a18cda3449e2320dfd8178c7decb76167cd4daead936c9b8349dccc35b9730acc3d2c79e21d90f771769c04d5bde3be80540cf0f4705c675bfe61530c35832ab828707aee3e5893277ee13c3a4aee5c71deb5c0f9a6faef40a05ca8545c2a9f002debf540c0e128a211f4944f8975163657f77288a9f183dac3a1b816eee0db635c0a87815720802661b0fec40a1c86e53cb028fca669b459c41f24c9602f03fd66245515c4e1c744f7c5e32329613886f7215fc236e5538fb3616f28ea353ec4cd845a60037fcf8ca1e0e7f18a01edb1cc41962fe6a86e212b7d750e74da30670d1f61c94a1147a36d3663849bdb6f3e63b5f15d3bd99622861f2601f862ef4e6158870e905fce076161f6b83d714f73a4f81969d57c30cc5729914a9ce6e267fd6f68642ad95634dd34ae840741506beb78497108bc1ecb3221d343d8fc82575b5ffe22a1f459cd07e701e0dbc54fb755411485dd362a3f40959ab70e4ba8f552416084f313730f9d283bdafa35d9c9fb557e20c0098745f19b496982679e3626034827e28641b4c92e790fbdd606137af9706e1886bc114cceda5258a6b04bbe97c48f41e6f688cace1563a7068c594d41233d693bcb383cedbd71cc1bc15a4c9927db5f9f346bd961889d3743639231550610f65121c3a1c289d9b748e2373f0020ac62278a9af1bb9f83d2e2f1399ccce18c0b3856a7ddedd75839d406d40ee64f142f81a02bbb765d45b2f33ab2887ac36d8ca91ff2a2e81919ca4f2645067d06d66870ca3c7fcbc255a4747cdf35b6c4a0c6c0a9eac885fdfa188a1a593338d251a95f94c78cb7762fc9dfded09b2b7b74a14af4e9d0beb6a0134b2167368f27b10cc686f050c32c7162cd364728406abf4dacef0e13fb3d08d53de8cacb4f9656ee65ec6f4ecdee5684ff18d56a6cc5802a5e71df0c97c64cce47ea63f5981cfec95798d42dfd630f7d9698d3a9c6026586547a131b3b6dfbea7edead4860e6de2918644d218df6c94d7047e24332d9a1b7ca14ba5a4c20d86e630fd33b797de2140b6e6de1fade2d5e6d3416fe8304b54ecc734f921685dc7ad7f2311ffc1892353b3c6832e2d113bd1fd37532a9b7ecd47cef361f2b42d0202529a15ee899127c6beaa54f5545c6b87383f7211db929142d7445ca2af2afd29da1c9fec40ce43155bdad752759f34be0e4b7c8440164c2be3beeeffad44d1661aa23c425e55f81c0b6029a84a46a3b7003d933b9cae2006a2d30d33221d96a46c8e4510b3225cad852ab54758329d32dffc46f6eaa754c69d86039a2d8396650cbc9c5197900f6e6fcd7d17c4c0b578997342d52d47cad6a88207123f6d525e939936768b8c3a4dd5de8f4b2ae70ca4e7ddc0919db2063e7a486270af6946020a1af967adfddf10b9e0e9ae06953e46e6263f5973e937805453c5cde523f6aa93d2f71fda6aa258b69fad426a7596a79ffd2cf93b8bedac9d077e1f04eee1a616cda7620a8f1a6c97eb833d96b56cd356724693eaa6d41f380051c99869c9bd53101ac87262c43025c7a7d90078efab3abd3feae0acb2c49f340cdef7d883862f4d179692f4aeb2f77051c08657690a95d2bf2c7481164213feca9b8934c9a2224c16adccd0484355280af6884788188898042cc1be130e4da120c358890e38ebbf81f28a29fe66bf527e41e5eb894dc6d68fc97bdbedfa18bdfb197dfe11d003c180a10debabc3aca959bf155d7a4799c0917fbf50ce4aed19b5e87f2c99c59f14ae22753f31a1b44db41dd9f6e2b33b84d320abb160ac04ed3f82c77770435efa74a7eff9f2c8caae9e88b275a3d7e6b5165118299ce2366561cbf0f74a123a0b037c39ae572270bdf5d07f9824c541fafb4a9cbad2722367af1719d8a061e5c0fd2f18461a93bede0296d128d4d8e291661766483b5e89a43b5a2ceb4d96ae1d93cbd0f3ebf0b30176166ca20a4b9d6983080a54f9f2def9a082c56690aac778cef6e204aabaae409e8c26ea7f9a7fa0dfb33a74b29893cb63201493fbc500038818e6ec882fc01c49059f46a3ae8c1829da062b9ed4bd2b2b22b5ba40371704315d38ae2ef775da8ba31338cd3879a4b719a33b763f33d7411e96d72f8d8f02d12771d94cde51746e4d98d0717c9aa6d4356b6380194c625305c0d8fcf7d931286576732d8efa48200dd927dfc6030421e5872471dc059c6e6b44a3fad344e6e03ef7261b7b186e0e7cbc03d8e85df33978e83772dc35634774de116ef48ec2ae0cb83b27a1c72c056f52dc999b95db5876a0a6de571a905018458363618b75892c74d33fae76c2428f83ced3b521d3f95f8578acd0158e3eb45c52ada497bf8352782e97ef5c05593a9096541aad6d08682a5bcfa1f3c309b0ca8b238f229bd72a5380af94884b78bbcf734be8e9a4b82585979dc0dd08e404f0d09fc3ec9cb40eb63e3a71ecab2d53be4acc3d5002c10a138d99ed215dd1d71964b3e54c5c5c078b98b614283d20e3d2e19c82773b1c2a46c93d87628d38907bc75537b4e1b7b100f6e6bc5815d6b614f75d64e8bb7c3e30929b2116c4951e8ca8555af7196e703d57f6543e9e963969d851fb068a513216962074327c254a536161d015f959680846e7c082f40db0873f66d757f8d81350cf616074de7affaa250c04e9e34defb6c7e268b2b3ad051a29b7bb37cdb374ed0e1b42369c2f5f7a358ba318c217197c8670ecc41d15ebb15</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title>「联合省选 2020 A」组合数问题</title>
    <url>/2022/03/24/%E3%80%8C%E8%81%94%E5%90%88%E7%9C%81%E9%80%89-2020-A%E3%80%8D%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>之前以为是我不会的科技题，没想到是勾巴题（（</p>
<p>观察到多项式次数 $m\le 1e3$，考虑计算每项的贡献：</p>
<p>$$\sum\limits_{i=0}^m a_i\sum\limits_{k=0}^n k^i x^k \dbinom n k$$</p>
<p>将 $k^i$ 用第二类斯特林数换掉：</p>
<p>$$\sum\limits_{i=0}^m a_i\sum\limits_{k=0}^nx^k\dbinom n k\sum\limits_{j=0}^{\min(k,i)}\dbinom k j\begin{Bmatrix}i\\j\end{Bmatrix}j!$$</p>
<p>然后推一下柿子：</p>
<p>$$\begin{aligned}\sum\limits_{i=0}^m a_i\sum\limits_{k=0}^nx^k\dbinom n k\sum\limits_{j=0}^{\min(k,i)}\dbinom k j\begin{Bmatrix}i\\j\end{Bmatrix}j!&amp;=\sum\limits_{i=0}^m\sum\limits_{j=0}^ia_i\begin{Bmatrix}i\\j\end{Bmatrix}j!\sum\limits_{k=j}^nx^k\dbinom n k\dbinom k j\\ &amp;=\sum\limits_{i=0}^m\sum\limits_{j=0}^ia_i\begin{Bmatrix}i\\j\end{Bmatrix}j!\sum\limits_{k=j}^nx^k\dbinom{n}{j}\dbinom{n-j}{k-j}\\ &amp;=\sum\limits_{i=0}^m\sum\limits_{j=0}^ia_i\begin{Bmatrix}i\\j\end{Bmatrix}j!\dbinom n j x^j\sum\limits_{k=0}^{n-j}\dbinom{n-j}{k}x^k\\ &amp;=\sum\limits_{i=0}^m\sum\limits_{j=0}^ia_i\begin{Bmatrix}i\\j\end{Bmatrix}j!\dbinom n j x^j(x+1)^{n-j}\end{aligned}$$</p>
<p>然后直接算就完了，时间复杂度 $\mathrm{O(m^2)}$。</p>
<p>$\texttt{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"></code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>斯特林数</tag>
        <tag>二项式定理</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1017G The Tree</title>
    <url>/2022/03/17/CF1017G-The-Tree/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1017G">$\text{link}$</a></p>
<p>对于询问 $\text{3 x}$ ，若操作 $\text{1 y}$ 使得 $x$ 染上了黑色，那么满足 $y$ 是 $x$ 的祖先并且 $y\longrightarrow$ 路径上操作 $1$ 的个数 $\ge$ 路径上的总点数（包括 $x,y$）。</p>
<p>考虑给每个点附一个权值 $-1$ ，操作 $\text{1 x}$ 则对 $x$ 单点 $+1$，那么查询时只需要判断 $x\longrightarrow rt$ 的路径上的后缀和最大值是否 $\ge 0$ 即可判断颜色，如果没有操作 $2$ 就做完了。</p>
<p>对于操作 $\text{2 x}$ ，将 $x$ 子树的权值覆盖为 $-1$ 可以使得子树内的点到 $x$ 的后缀和最大值正确，但是可能 $x\longrightarrow rt$ 的后缀和最大值出错，这需要将 $x$ 单点减小 “$rt\longrightarrow x$ 的后缀和最大值 + 1” ，然后就做完了。</p>
<p>时间复杂度 $\mathrm{O(n\log ^2 n)}$ 。</p>
<p><del>久违的 1A</del></p>
<p>$\texttt{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];
<span class="hljs-type">int</span> n, q, s[maxn], fa[maxn], depth[maxn], son[maxn], top[maxn], tms, dfn[maxn];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath)</span> </span>{
    s[u] = <span class="hljs-number">1</span>; fa[u] = fath;
    depth[u] = depth[fath] + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) {
        <span class="hljs-built_in">dfs1</span>(v, u);
        s[u] += s[v];
        <span class="hljs-keyword">if</span> (s[v] &gt; s[son[u]]) son[u] = v;
    }
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> Top)</span> </span>{
    top[u] = Top; dfn[u] = ++tms;
    <span class="hljs-keyword">if</span> (!son[u]) <span class="hljs-keyword">return</span>;
    <span class="hljs-built_in">dfs2</span>(son[u], Top);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[u]) <span class="hljs-keyword">if</span> (v ^ son[u]) <span class="hljs-built_in">dfs2</span>(v, v);
}
<span class="hljs-keyword">namespace</span> _Smt {
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> lson ls, l, mid</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rson rs, mid + 1, r</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> len, s, rx, tag;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag = <span class="hljs-number">1</span>; s = -len; rx = <span class="hljs-number">-1</span>;}
    } t[maxn &lt;&lt; <span class="hljs-number">2</span>], ept;
    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{
        c.s = a.s + b.s;
        c.rx = <span class="hljs-built_in">max</span>(b.rx, a.rx + b.s);
        <span class="hljs-keyword">return</span> c;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
        t[u].len = r - l + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (l == r) {t[u].s = t[u].rx = <span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>;}
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(lson); <span class="hljs-built_in">build</span>(rson);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        <span class="hljs-keyword">if</span> (t[u].tag) {
            t[ls].<span class="hljs-built_in">ladd</span>();
            t[rs].<span class="hljs-built_in">ladd</span>();
            t[u].tag = <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (l == r) {t[u].s += y; t[u].rx += y; <span class="hljs-keyword">return</span>;}
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(lson, x, y);
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf1</span>(rson, x, y);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(); <span class="hljs-keyword">return</span>;}
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(lson, x, y);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rson, x, y);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(lson, x, y);
        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rson, x, y);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(lson, x, y), <span class="hljs-built_in">qry</span>(rson, x, y));
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        Node res = ept;
        res.rx = <span class="hljs-number">-1e9</span>;
        <span class="hljs-keyword">while</span> (top[u] ^ <span class="hljs-number">1</span>) {
            res = <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[top[u]], dfn[u]), res);
            u = fa[top[u]];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(ept, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, dfn[u]), res).rx;
    }
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> lson</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rson</span>
}
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;q);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-type">int</span> u; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;u);
        G[u].<span class="hljs-built_in">push_back</span>(i);
    }
    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
    <span class="hljs-keyword">while</span> (q--) {
        <span class="hljs-type">int</span> opt, x; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;opt, &amp;x);
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {
            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], dfn[x] + s[x] - <span class="hljs-number">1</span>);
            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, dfn[x], -<span class="hljs-built_in">ask</span>(x) - <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-built_in">ask</span>(x) &gt;= <span class="hljs-number">0</span> ? <span class="hljs-string">"black"</span> : <span class="hljs-string">"white"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队二次离线学习笔记</title>
    <url>/2022/03/17/%E8%8E%AB%E9%98%9F%E4%BA%8C%E6%AC%A1%E7%A6%BB%E7%BA%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.com.cn/problem/P4887">$\texttt{Luogu P4887 [模板]莫队二次离线}$</a></p>
<p>设莫队指针移动时间复杂度为 $O(k)$ ，则普通莫队的时间复杂度为 $O(m\sqrt n k)$ ，使用莫队二次离线可以变成 $O(m\sqrt n + nk)$ 。</p>
<p>本题直接莫队做是 $O(m\sqrt n\binom{14}{k})$ 的，无法通过。</p>
<p>记 $a_x$ 对区间 $[l,r]$ 的贡献为 $f(x,[l,r])$，<strong>差分</strong>后贡献记为 $f(x,r)-f(x,l-1)$，即 $f(x,r)$ 表示 $x$ 对前缀 $[1,r]$ 的贡献。考虑莫队指针移动过程中答案的变化：</p>
<ul>
<li><p>$[l,r]\longrightarrow [l,qr]:$</p>
<ul>
<li><p>$qr &gt; r:$ 答案增加 $\sum\limits_{i=r+1}^{qr}f(i,i-1)-f(i,l-1)$</p>
</li>
<li><p>$qr &lt; r:$ 答案减少 $\sum\limits_{i=qr+1}^r f(i,i-1) - f(i,l-1)$</p>
</li>
</ul>
</li>
<li><p>$[l,r]\longrightarrow [ql,r]:$</p>
<ul>
<li><p>$ql &lt; l:$ 答案增加 $\sum\limits_{i=ql}^{l-1} f(i,r)-f(i,i)$</p>
</li>
<li><p>$ql &gt; l:$ 答案减少 $\sum\limits_{i=l}^{ql-1} f(i,r)-f(i,i)$</p>
</li>
</ul>
</li>
</ul>
<p>$f(i,i)$ 和 $f(i,i-1)$ 都是固定的，可以预处理直接计算；</p>
<p>$f(i,l-1)$ 和 $f(i,r)$ 则使用扫描线解决，具体地说：</p>
<ul>
<li><p>对于每个前缀 $[1,i]$，开一个 $vector$ 存下所有的询问 $f([l,r],i)$，记 $g(x)$ 表示 $a_{[1,i]}$ 中 $\oplus x$ 的二进制表示下恰好有 $k$ 个 $1$ 的个数，则对于询问 $f([l,r],i)$ 的贡献即为 $\sum\limits_{i=l}^r g(a_i)$。</p>
</li>
<li><p>处理完 $[1,i]$ 然后处理 $[1,i+1]$ 时，枚举 $a_{i+1}$ 取反 $k$ 位更新 $g$ 即可。</p>
</li>
</ul>
<p>询问可以用四元组 $(l,r,id,1/-1)$ 表示询问 $f([l,r],i)$，询问编号 $id$ 以及增减 $1/-1$。</p>
<p>$\texttt{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> f ? -x : x;
}
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, k, a[maxn], B;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {
    <span class="hljs-type">int</span> l, r, id, pos;
    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> _ques &amp;a) <span class="hljs-type">const</span> {
        <span class="hljs-keyword">return</span> pos ^ a.pos ? l &lt; a.l : pos &amp; <span class="hljs-number">1</span> ? r &gt; a.r : r &lt; a.r;
    }
} qr[maxn];
<span class="hljs-type">long</span> <span class="hljs-type">long</span> sum[maxn], ans[maxn];
<span class="hljs-type">int</span> f[maxn], g[maxn];
vector&lt;<span class="hljs-type">int</span>&gt; trs;
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">st</span> {
    <span class="hljs-type">int</span> l, r, id, dt;
    <span class="hljs-built_in">st</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> dt = <span class="hljs-number">0</span>) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">r</span>(r), <span class="hljs-built_in">id</span>(id), <span class="hljs-built_in">dt</span>(dt) {}
};
vector&lt;st&gt; vec[maxn];
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();
    B = <span class="hljs-built_in">sqrt</span>(n);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
        <span class="hljs-type">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();
        qr[i] = (_ques){l, r, i, l / B};
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> S = <span class="hljs-number">0</span>; S &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>); S++) {
        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++) cnt += S &gt;&gt; i &amp; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (cnt == k) trs.<span class="hljs-built_in">pb</span>(S);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        f[i] = g[a[i]];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> S : trs) g[a[i] ^ S]++;
    }
    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(g));
    <span class="hljs-built_in">sort</span>(qr + <span class="hljs-number">1</span>, qr + m + <span class="hljs-number">1</span>);
    <span class="hljs-type">int</span> l = qr[<span class="hljs-number">1</span>].l, r = qr[<span class="hljs-number">1</span>].r;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l + <span class="hljs-number">1</span>; i &lt;= r; i++) sum[<span class="hljs-number">1</span>] += f[i];
    <span class="hljs-keyword">if</span> (l &lt; r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(l + <span class="hljs-number">1</span>, r, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= m; i++) {
        <span class="hljs-keyword">if</span> (r &lt; qr[i].r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(r + <span class="hljs-number">1</span>, qr[i].r, i, <span class="hljs-number">-1</span>));
        <span class="hljs-keyword">if</span> (r &gt; qr[i].r) vec[l - <span class="hljs-number">1</span>].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(qr[i].r + <span class="hljs-number">1</span>, r, i, <span class="hljs-number">1</span>));
        <span class="hljs-keyword">while</span> (r &lt; qr[i].r) sum[i] += f[++r];
        <span class="hljs-keyword">while</span> (r &gt; qr[i].r) sum[i] -= f[r--];
        <span class="hljs-keyword">if</span> (l &gt; qr[i].l) vec[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(qr[i].l, l - <span class="hljs-number">1</span>, i, <span class="hljs-number">1</span>));
        <span class="hljs-keyword">if</span> (l &lt; qr[i].l) vec[r].<span class="hljs-built_in">pb</span>(<span class="hljs-built_in">st</span>(l, qr[i].l - <span class="hljs-number">1</span>, i, <span class="hljs-number">-1</span>));
        <span class="hljs-keyword">while</span> (l &gt; qr[i].l) sum[i] -= f[--l];
        <span class="hljs-keyword">while</span> (l &lt; qr[i].l) sum[i] += f[l++];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> S : trs) g[a[i] ^ S]++;
        <span class="hljs-keyword">for</span> (st qry : vec[i]) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = qry.l; j &lt;= qry.r; j++) {
                sum[qry.id] += qry.dt * g[a[j]];
                <span class="hljs-keyword">if</span> (j &lt;= i &amp;&amp; k == <span class="hljs-number">0</span>) sum[qry.id] -= qry.dt;
            }
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) {
        sum[i] += sum[i - <span class="hljs-number">1</span>];
        ans[qr[i].id] = sum[i];
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans[i]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>

<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ul>
<li><p><a href="https://www.luogu.com.cn/problem/P7906">$\text{[Ynoi2005] rpxleqxq}$</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5047">$\text{[Ynoi2019 模拟赛] Yuno loves sqrt technology II}$</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5501">$\text{[LnOI2019]来者不拒，去者不追}$</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P5398">$\text{[Ynoi2018] GOSICK}$</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>群论学习笔记</title>
    <url>/2022/03/16/%E7%BE%A4%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>参考资料： <a href="https://www.luogu.com.cn/blog/command-block/qun-lun-xiao-ji">command_block’s blog</a></p>
</blockquote>
<h1 id="群的概念及基本性质"><a href="#群的概念及基本性质" class="headerlink" title="群的概念及基本性质"></a>群的概念及基本性质</h1><ul>
<li><p>由集合 $G\neq \emptyset$ 和 $G$ 上的二元运算 $*$ 组成。</p>
</li>
<li><p>满足以下性质：</p>
<ul>
<li><p>封闭性：$\forall a,b\in G,$ 均有 $(a*b)\in G$。</p>
</li>
<li><p>结合律：$(a*b)*c=a*(b*c)$ 。</p>
</li>
<li><p>存在单位元：存在 $\epsilon\in G$ 使得 $\forall a\in G$，均有 $a*\epsilon=\epsilon *a=a$ 。</p>
</li>
<li><p>存在逆元：$\forall a \in G,$ 均存在 $b\in G$ 使得 $a*b=\epsilon$。</p>
</li>
</ul>
</li>
<li><p>定理：单位元唯一。证明略去。</p>
</li>
<li><p>定理：每个元素的逆元唯一。证明略去。</p>
</li>
<li><p>定理：对于任意的有限群 $G={\epsilon,a_1,…,a_n}$，$\forall a\in G$，均存在一个常数 $b$ 使得 $a^b=\epsilon$，且有 $a^{-1}=a^{b-1}$ ，称 $b$ 为 $a$ 的阶。证明略去。</p>
</li>
</ul>
<h1 id="置换与置换群"><a href="#置换与置换群" class="headerlink" title="置换与置换群"></a>置换与置换群</h1><ul>
<li><p>置换的定义：有限集合到自身的双射称作置换。</p>
<p>  可以写作</p>
<p>  $$\large\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\end{pmatrix}$$</p>
</li>
<li><p>置换的乘法：相当于将映射叠加。</p>
<p>  性质：</p>
<ul>
<li><p>置换的乘积还是置换。</p>
</li>
<li><p>满足交换律。</p>
</li>
<li><p>单位元为 $\large\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\1&amp;2&amp;3&amp;…&amp;n\end{pmatrix}$</p>
</li>
<li><p>$\begin{pmatrix}1&amp;2&amp;3&amp;…&amp;n\\p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\end{pmatrix}$ 的逆元为 $\begin{pmatrix}p_1&amp;p_2&amp;p_3&amp;…&amp;p_n\\1&amp;2&amp;3&amp;…&amp;n\end{pmatrix}$</p>
</li>
</ul>
<p>  一般不满足交换律。</p>
</li>
<li><p>置换群：由上面的性质可知对 $1..n$ 作用的所有置换形成一个群。一般只研究一个子群。</p>
</li>
<li><p>置换的循环：把置换看作有向图，连边 $(i,p_i)$，会形成若干个环。</p>
<p>  置换可以用这些环来表示，并且是唯一的。</p>
</li>
</ul>
<h1 id="text-Burnside-引理-与-text-Polya-定理"><a href="#text-Burnside-引理-与-text-Polya-定理" class="headerlink" title="$\text{Burnside}$ 引理 与 $\text{Polya}$ 定理"></a>$\text{Burnside}$ 引理 与 $\text{Polya}$ 定理</h1><p>设 $G$ 为 $1..n$ 的一个置换群。</p>
<ul>
<li><p>不动点：对于 $p\in G$ ，若 $p_k = k$ 则称 $k$ 是 $p$ 下的不动点。</p>
<p>  $p$ 下的不动点个数记作 $c(p)$。</p>
</li>
<li><p>$\text{k}$ 不动置换类</p>
<p>  对于 $p\in G$，若 $k$ 是 $p$ 下的不动点，则称 $p$ 属于 $\text{k}$ 不动置换类，记作 $p\in Z_k$。$Z_k$ 为 $G$ 的一个子群。</p>
</li>
<li><p>等价类：等价类 $E_k$ 为对元素 $k$ 任意施加 $G$ 中的置换所能到达的元素集合。</p>
<ul>
<li>定理：当 $x,y$ 同属一个等价类时，有 $|Z_x| = |Z_y|$。证明略去。</li>
</ul>
</li>
<li><p>轨道-稳定子定理：</p>
<p>  $$|Z_k|\times|E_k|=G$$</p>
<p>  证明略去。</p>
</li>
<li><p>$\text{Burnside 引理}$ ：</p>
<p>  记 $l$ 为 $E_{1..n}$ 中本质不同的等价类个数，则有： </p>
<p>  $$l = \large\dfrac 1 {|G|}\sum\limits_{p\in G}c(p)$$</p>
<p>  即等价类个数 $=$ 所有置换下的不动点总数的平均数。</p>
</li>
<li><p>$\text{Polya 定理}$:</p>
<p>  设有 $n$ 个元素，每个元素有 $m$ 种染色方案。</p>
<p>  设 $G$ 是 $n$ 个元素的置换群，则染色总方案数为：</p>
<p>  $$\large\dfrac 1 {|G|}\sum\limits_{p\in G}T(p)$$</p>
<p>  其中 $T(p)$ 表示在置换 $p$ 下不动的染色方案数。</p>
</li>
</ul>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p><a href="https://www.luogu.com.cn/problem/P4980">$\text{[模板]Polya 定理}$</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4916">$\text{[MtOI2018]魔力环}$</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4727">$\text{[HNOI2009]图的同构计数}$</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4128">$\text{[SHOI2006] 有色图}$</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>CF1109F Sasha and Algorithm of Silence&#39;s Sounds</title>
    <url>/2022/03/16/CF1109F-Sasha-and-Algorithm-of-Silence-s-Sounds/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1109F">$\text{link}$</a></p>
<p>首先考虑计算每个左端点对应的合法右端点的个数，可以发现随着 $l$ 的增大，使得 $[l,r]$ 不存在环的最大的 $r$ 是单调递增的，然后我就不会了。。。</p>
<p>看了题解才想起来可以利用树“点数-边数=1”的性质计算，于是拿棵线段树顺便维护一下“点数-边数”的最小值以及最小值的个数就好了，因为 $[l,l]$ 显然满足 “点数-边数=1” 。</p>
<p>时间复杂度 $\mathrm{O(nm\log(nm))}$ 。</p>
<p>这种性质还是要想的起来啊。</p>
<p>线段树四倍空间 /fn/fn/fn</p>
<p>$\text{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, nm, a[maxn][maxn];
vector&lt;<span class="hljs-type">int</span>&gt; G[maxm];
<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;
<span class="hljs-keyword">namespace</span> LCT {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>], fa, tag;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clr</span><span class="hljs-params">()</span> </span>{ch[<span class="hljs-number">0</span>] = ch[<span class="hljs-number">1</span>] = fa = tag = <span class="hljs-number">0</span>;}
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag ^= <span class="hljs-number">1</span>; <span class="hljs-built_in">swap</span>(ch[<span class="hljs-number">0</span>], ch[<span class="hljs-number">1</span>]);}
    } t[maxm];
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">nrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">return</span> t[t[x].fa].ch[<span class="hljs-number">0</span>] == x || t[t[x].fa].ch[<span class="hljs-number">1</span>] == x;}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y)) t[z].ch[t[z].ch[<span class="hljs-number">1</span>] == y] = x;
        t[t[y].fa = x].fa = z;
        <span class="hljs-type">int</span> gx = t[y].ch[<span class="hljs-number">1</span>] == x;
        t[y].ch[gx] = t[x].ch[gx ^ <span class="hljs-number">1</span>];
        t[t[x].ch[gx ^ <span class="hljs-number">1</span>]].fa = y;
        t[x].ch[gx ^ <span class="hljs-number">1</span>] = y;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-keyword">if</span> (t[x].tag) {
            t[t[x].ch[<span class="hljs-number">0</span>]].<span class="hljs-built_in">ladd</span>();
            t[t[x].ch[<span class="hljs-number">1</span>]].<span class="hljs-built_in">ladd</span>();
            t[x].tag = <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-type">int</span> stk[maxm], top;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-type">int</span> u = x;
        <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">nrt</span>(u); u = t[u].fa) stk[++top] = u;
        <span class="hljs-built_in">pd</span>(u); <span class="hljs-keyword">while</span> (top) <span class="hljs-built_in">pd</span>(stk[top--]);
        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nrt</span>(x)) {
            <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y) &amp;&amp; ((t[z].ch[<span class="hljs-number">0</span>] == y) == (t[y].ch[<span class="hljs-number">0</span>] == x))) <span class="hljs-built_in">rotate</span>(y);
            <span class="hljs-built_in">rotate</span>(x);
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; x; y = x, x = t[x].fa) <span class="hljs-built_in">splay</span>(x), t[x].ch[<span class="hljs-number">1</span>] = y;}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x); t[x].<span class="hljs-built_in">ladd</span>();}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">mrt</span>(x); <span class="hljs-built_in">access</span>(y); <span class="hljs-built_in">splay</span>(y);}
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">split</span>(x, y); t[x].fa = t[y].ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;}
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">frt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{
        <span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x);
        <span class="hljs-keyword">while</span> (t[x].ch[<span class="hljs-number">0</span>]) <span class="hljs-built_in">pd</span>(x), x = t[x].ch[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">splay</span>(x); <span class="hljs-keyword">return</span> x;
    }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-built_in">mrt</span>(x);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">frt</span>(y) == x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        t[x].fa = y; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
}
<span class="hljs-keyword">namespace</span> _Smt {
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> mn, sz, tag;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{mn += x; tag += x;}
    } t[maxm &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{
        <span class="hljs-keyword">if</span> (a.mn &lt; b.mn) c.mn = a.mn, c.sz = a.sz;
        <span class="hljs-keyword">if</span> (a.mn &gt; b.mn) c.mn = b.mn, c.sz = b.sz;
        <span class="hljs-keyword">if</span> (a.mn == b.mn) c.mn = a.mn, c.sz = a.sz + b.sz;
        <span class="hljs-keyword">return</span> c;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        <span class="hljs-keyword">if</span> (t[u].tag) {
            t[ls].<span class="hljs-built_in">ladd</span>(t[u].tag);
            t[rs].<span class="hljs-built_in">ladd</span>(t[u].tag);
            t[u].tag = <span class="hljs-number">0</span>;
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (l == r) {t[u] = (Node){y, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}; <span class="hljs-keyword">return</span>;}
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf</span>(ls, l, mid, x, y);
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(z); <span class="hljs-keyword">return</span>;}
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);
        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);
    }
    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);
        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>((Node){<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, <span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));
    }
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>
    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>
}
<span class="hljs-type">int</span> lx;
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lk</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> x)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++) {
        <span class="hljs-type">int</span> v = G[x][i];
        <span class="hljs-keyword">if</span> (v &lt; l || v &gt; x) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (!LCT::<span class="hljs-built_in">link</span>(x, v)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
                <span class="hljs-keyword">if</span> (G[x][j] &lt; l || G[x][j] &gt; x) <span class="hljs-keyword">continue</span>;
                LCT::<span class="hljs-built_in">cut</span>(x, G[x][j]);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        lx++;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-type">int</span> dt;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> r)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[x]) {
        <span class="hljs-keyword">if</span> (v &gt; r || v &lt; x) <span class="hljs-keyword">continue</span>;
        LCT::<span class="hljs-built_in">cut</span>(x, v);
        <span class="hljs-comment">// printf("? %d %d %d\n", x, v, r);</span>
        _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, v, r, <span class="hljs-number">1</span>);
    }
}
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> r = <span class="hljs-number">2</span>;
    _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt; nm; l++) {
        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>
        <span class="hljs-keyword">while</span> (r &lt;= nm) {
            lx = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">lk</span>(l, r)) <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">// printf("%d %d %d\n", r, qry2(1, 1, nm, r - 1), lx);</span>
            _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r, _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r - <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>).mn + <span class="hljs-number">1</span> - lx);
            r++;
        }
        ans += _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l, r - <span class="hljs-number">1</span>).sz;
        <span class="hljs-comment">// printf("%d %d %d %d\n", l, r - 1, _Smt::qry(1, 1, nm, l, r - 1).mn, _Smt::qry(1, 1, nm, l, r - 1).sz);</span>
        <span class="hljs-comment">// for (int i = l; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>
        <span class="hljs-built_in">ct</span>(l, r - <span class="hljs-number">1</span>); _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);
        <span class="hljs-comment">// puts("?");</span>
        <span class="hljs-comment">// for (int i = l + 1; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>
        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>
    }
    ans++;
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m); nm = n * m;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i][j]);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i - <span class="hljs-number">1</span>][j]);
        <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j - <span class="hljs-number">1</span>]);
        <span class="hljs-keyword">if</span> (i &lt; n) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i + <span class="hljs-number">1</span>][j]);
        <span class="hljs-keyword">if</span> (j &lt; m) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j + <span class="hljs-number">1</span>]);
    }
    <span class="hljs-built_in">solve</span>();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>LCT</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>CF232E Quick Tortoise</title>
    <url>/2022/03/15/CF232E-Quick-Tortoise/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF232E">$\text{link}$</a></p>
<p>先将询问离线下来分治，设当前分治区间为 $[l,r]$ , $mid = (l + r) &gt;&gt; 1$，考虑处理左上角到右下角的询问，剩下的分到左右两边。</p>
<p>由于路径必然经过 $y=mid$ 这条直线，考虑记 $g1(i,j,k) = 1/0$ 表示 $(i,j)$ 能否走到 $(k,mid)$， $g2(i,j,k) = 1/0$ 表示 $(k,mid)$ 能否走到 $(i,j)$，</p>
<p>然后转移用 $bitset$ 优化一下就可以做到 $\mathrm{O(\dfrac {n^2m\log m}{\omega} + \dfrac {qn}{\omega})}$ 。</p>
<p>实现的时候 $(i,j)$ 的意义是反过来的（（</p>
<p>$\text{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> f ? -x : x;
}
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">500</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxq = <span class="hljs-number">6e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, m, ans[maxq]; <span class="hljs-type">char</span> c[maxn][maxn];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {
    <span class="hljs-type">int</span> xl, yl, xr, yr, id;
} qr[maxq], q0[maxq], q1[maxq];
<span class="hljs-type">int</span> ck[maxn];
bitset&lt;maxn&gt; g1[maxn][maxn], g2[maxn][maxn];
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>{
    <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (l == r) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ck[i] = ck[i - <span class="hljs-number">1</span>] + (c[i][r] == <span class="hljs-string">'#'</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)
        <span class="hljs-keyword">if</span> (ck[qr[i].xr] == ck[qr[i].xl - <span class="hljs-number">1</span>]) ans[qr[i].id] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, c0 = <span class="hljs-number">0</span>, c1 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++)
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) g1[j][i].<span class="hljs-built_in">reset</span>(), g2[j][i].<span class="hljs-built_in">reset</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {
            <span class="hljs-keyword">if</span> (i) g2[mid][i] |= g2[mid][i - <span class="hljs-number">1</span>];
            g2[mid][i].<span class="hljs-built_in">set</span>(i);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &lt;= r; j++) {
            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (i) g2[j][i] |= g2[j][i - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (j &gt; mid) g2[j][i] |= g2[j - <span class="hljs-number">1</span>][i];
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) {
        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {
            <span class="hljs-keyword">if</span> (i &lt; n) g1[mid][i] |= g1[mid][i + <span class="hljs-number">1</span>];
            g1[mid][i].<span class="hljs-built_in">set</span>(i);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &gt;= l; j--) {
            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (i &lt; n) g1[j][i] |= g1[j][i + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (j &lt; mid) g1[j][i] |= g1[j + <span class="hljs-number">1</span>][i];
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)
    <span class="hljs-keyword">if</span> (qr[i].yr &lt;= mid) q0[++c0] = qr[i];
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qr[i].yl &gt; mid) q1[++c1] = qr[i];
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// printf("%d %d %d\n", qr[i].id, g1[qr[i].yl][qr[i].xl].count(), g2[qr[i].yr][qr[i].xr].count());</span>
        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g1[qr[i].yl][qr[i].xl][j] ? 1 : 0); puts("");</span>
        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g2[qr[i].yr][qr[i].xr][j] ? 1 : 0); puts("");</span>
        <span class="hljs-keyword">if</span> ((g1[qr[i].yl][qr[i].xl] &amp; g2[qr[i].yr][qr[i].xr]).<span class="hljs-built_in">count</span>()) ans[qr[i].id] = <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c0; i++) qr[L + i - <span class="hljs-number">1</span>] = q0[i];
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c1; i++) qr[R - i + <span class="hljs-number">1</span>] = q1[i];
    <span class="hljs-built_in">solve</span>(l, mid, L, L + c0 - <span class="hljs-number">1</span>);
    <span class="hljs-built_in">solve</span>(mid + <span class="hljs-number">1</span>, r, R - c1 + <span class="hljs-number">1</span>, R);
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, c[i] + <span class="hljs-number">1</span>);
    <span class="hljs-type">int</span> q = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) {
        <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();
        qr[i].xl = x; qr[i].yl = y;
        x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();
        qr[i].xr = x; qr[i].yr = y;
        qr[i].id = i;
    }
    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, q);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) <span class="hljs-built_in">puts</span>(ans[i] ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>「雅礼集训 2018 Day7」A</title>
    <url>/2022/03/15/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day7%E3%80%8DA/</url>
    <content><![CDATA[<p><a href="https://loj.ac/p/6507">$\text{link}$</a></p>
<p>用线段树维护 $\text{And,Or,Min}$ 值，对于操作：</p>
<ul>
<li><p>$\text{And x}$，设当前点为 $u$，区间值分别为 $ta(u),to(u),tm(u)$：</p>
<ul>
<li><p>若 $x \And to(u) = to(u)$ ,则该操作对当前区间 $[l(u),r(u)]$ 的值无效；</p>
</li>
<li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p>
</li>
<li><p>否则直接暴力递归下去。</p>
</li>
</ul>
</li>
<li><p>$\text{Or x}$，类似的有：</p>
<ul>
<li><p>若 $ta(u) \And x = x$ ,则该操作对当前区间无效；</p>
</li>
<li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p>
</li>
<li><p>否则直接暴力递归下去。</p>
</li>
</ul>
</li>
</ul>
<p>分析一下时间复杂度：每次暴力递归下去都会使得当前区间内所有数的某一位相同，每个区间不同位的总数为 $\mathrm{O(n\log n\log 值域)}$，时间复杂度即为 $\mathrm{O(n\log n\log 值域)}$ 。</p>
<p>$\text{Code:}$</p>
<div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> f ? -x : x;
}
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-type">int</span> n, q, a[maxn];
<span class="hljs-keyword">namespace</span> _Smt {
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {
        <span class="hljs-type">int</span> a, o, m, tg1, tg2;
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a &amp;= x; o &amp;= x; m &amp;= x; tg1 = ~tg1 ? tg1 &amp; x : x; tg2 &amp;= x;}
        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a |= x; o |= x; m |= x; tg2 |= x; tg1 = ~tg1 ? tg1 ^ (tg1 &amp; x) : tg1;}
    } t[maxn &lt;&lt; <span class="hljs-number">2</span>];
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        t[u].a = t[ls].a &amp; t[rs].a;
        t[u].o = t[ls].o | t[rs].o;
        t[u].m = <span class="hljs-built_in">min</span>(t[ls].m, t[rs].m);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{
        <span class="hljs-keyword">if</span> (~t[u].tg1) t[ls].<span class="hljs-built_in">aladd</span>(t[u].tg1), t[rs].<span class="hljs-built_in">aladd</span>(t[u].tg1);
        <span class="hljs-keyword">if</span> (t[u].tg2) t[ls].<span class="hljs-built_in">oladd</span>(t[u].tg2), t[rs].<span class="hljs-built_in">oladd</span>(t[u].tg2);
        t[u].tg1 = <span class="hljs-number">-1</span>; t[u].tg2 = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{
        t[u].tg1 = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span> (l == r) {
            t[u].a = t[u].o = t[u].m = a[l];
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(ls, l, mid);
        <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);
        <span class="hljs-built_in">up</span>(u);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">if</span> ((z &amp; t[u].o) == t[u].o) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {
            <span class="hljs-keyword">if</span> (l == r) {
                t[u].<span class="hljs-built_in">aladd</span>(z);
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {
                t[u].<span class="hljs-built_in">aladd</span>(z);
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(ls, l, mid, x, y, z);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf1</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);
        <span class="hljs-built_in">up</span>(u);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{
        <span class="hljs-keyword">if</span> ((t[u].a &amp; z) == z) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {
            <span class="hljs-keyword">if</span> (l == r) {
                t[u].<span class="hljs-built_in">oladd</span>(z);
                <span class="hljs-keyword">return</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {
                t[u].<span class="hljs-built_in">oladd</span>(z);
                <span class="hljs-keyword">return</span>;
            }
        }
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);
        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);
        <span class="hljs-built_in">up</span>(u);
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{
        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u].m;
        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">pd</span>(u);
        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);
        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));
    }
}
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();
    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);
    <span class="hljs-keyword">while</span> (q--) {
        <span class="hljs-type">int</span> opt, l, r, x;
        opt = <span class="hljs-built_in">read</span>(); l = <span class="hljs-built_in">read</span>(); r = <span class="hljs-built_in">read</span>();
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) {
            x = <span class="hljs-built_in">read</span>();
            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);
        }
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {
            x = <span class="hljs-built_in">read</span>();
            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);
        }
        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r));
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre></div>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>势能分析</tag>
      </tags>
  </entry>
</search>
