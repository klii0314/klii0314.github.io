<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>klii&#39;s blog</title>
  
  
  <link href="https://klii0314.github.io/atom.xml" rel="self"/>
  
  <link href="https://klii0314.github.io/"/>
  <updated>2022-03-16T03:28:42.629Z</updated>
  <id>https://klii0314.github.io/</id>
  
  <author>
    <name>klii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CF1109F Sasha and Algorithm of Silence&#39;s Sounds</title>
    <link href="https://klii0314.github.io/2022/03/16/CF1109F-Sasha-and-Algorithm-of-Silence-s-Sounds/"/>
    <id>https://klii0314.github.io/2022/03/16/CF1109F-Sasha-and-Algorithm-of-Silence-s-Sounds/</id>
    <published>2022-03-16T03:21:01.000Z</published>
    <updated>2022-03-16T03:28:42.629Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF1109F">$\text{link}$</a></p><p>首先考虑计算每个左端点对应的合法右端点的个数，可以发现随着 $l$ 的增大，使得 $[l,r]$ 不存在环的最大的 $r$ 是单调递增的，然后我就不会了。。。</p><p>看了题解才想起来可以利用树“点数-边数=1”的性质计算，于是拿棵线段树顺便维护一下“点数-边数”的最小值以及最小值的个数就好了，因为 $[l,l]$ 显然满足 “点数-边数=1” 。</p><p>时间复杂度 $\mathrm{O(nm\log(nm))}$ 。</p><p>这种性质还是要想的起来啊。</p><p>线段树四倍空间 /fn/fn/fn</p><p>$\text{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb push_back</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxm = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, nm, a[maxn][maxn];vector&lt;<span class="hljs-type">int</span>&gt; G[maxm];<span class="hljs-type">long</span> <span class="hljs-type">long</span> ans;<span class="hljs-keyword">namespace</span> LCT {    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> ch[<span class="hljs-number">2</span>], fa, tag;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clr</span><span class="hljs-params">()</span> </span>{ch[<span class="hljs-number">0</span>] = ch[<span class="hljs-number">1</span>] = fa = tag = <span class="hljs-number">0</span>;}        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">()</span> </span>{tag ^= <span class="hljs-number">1</span>; <span class="hljs-built_in">swap</span>(ch[<span class="hljs-number">0</span>], ch[<span class="hljs-number">1</span>]);}    } t[maxm];    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">nrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">return</span> t[t[x].fa].ch[<span class="hljs-number">0</span>] == x || t[t[x].fa].ch[<span class="hljs-number">1</span>] == x;}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y)) t[z].ch[t[z].ch[<span class="hljs-number">1</span>] == y] = x;        t[t[y].fa = x].fa = z;        <span class="hljs-type">int</span> gx = t[y].ch[<span class="hljs-number">1</span>] == x;        t[y].ch[gx] = t[x].ch[gx ^ <span class="hljs-number">1</span>];        t[t[x].ch[gx ^ <span class="hljs-number">1</span>]].fa = y;        t[x].ch[gx ^ <span class="hljs-number">1</span>] = y;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-keyword">if</span> (t[x].tag) {            t[t[x].ch[<span class="hljs-number">0</span>]].<span class="hljs-built_in">ladd</span>();            t[t[x].ch[<span class="hljs-number">1</span>]].<span class="hljs-built_in">ladd</span>();            t[x].tag = <span class="hljs-number">0</span>;        }    }    <span class="hljs-type">int</span> stk[maxm], top;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-type">int</span> u = x;        <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">nrt</span>(u); u = t[u].fa) stk[++top] = u;        <span class="hljs-built_in">pd</span>(u); <span class="hljs-keyword">while</span> (top) <span class="hljs-built_in">pd</span>(stk[top--]);        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">nrt</span>(x)) {            <span class="hljs-type">int</span> y = t[x].fa, z = t[y].fa;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nrt</span>(y) &amp;&amp; ((t[z].ch[<span class="hljs-number">0</span>] == y) == (t[y].ch[<span class="hljs-number">0</span>] == x))) <span class="hljs-built_in">rotate</span>(y);            <span class="hljs-built_in">rotate</span>(x);        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; x; y = x, x = t[x].fa) <span class="hljs-built_in">splay</span>(x), t[x].ch[<span class="hljs-number">1</span>] = y;}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{<span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x); t[x].<span class="hljs-built_in">ladd</span>();}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">mrt</span>(x); <span class="hljs-built_in">access</span>(y); <span class="hljs-built_in">splay</span>(y);}    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{<span class="hljs-built_in">split</span>(x, y); t[x].fa = t[y].ch[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;}    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">frt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{        <span class="hljs-built_in">access</span>(x); <span class="hljs-built_in">splay</span>(x);        <span class="hljs-keyword">while</span> (t[x].ch[<span class="hljs-number">0</span>]) <span class="hljs-built_in">pd</span>(x), x = t[x].ch[<span class="hljs-number">0</span>];        <span class="hljs-built_in">splay</span>(x); <span class="hljs-keyword">return</span> x;    }    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-built_in">mrt</span>(x);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">frt</span>(y) == x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        t[x].fa = y; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    }}<span class="hljs-keyword">namespace</span> _Smt {    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> mn, sz, tag;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{mn += x; tag += x;}    } t[maxm &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-function">Node <span class="hljs-title">merge</span><span class="hljs-params">(Node c, Node a, Node b)</span> </span>{        <span class="hljs-keyword">if</span> (a.mn &lt; b.mn) c.mn = a.mn, c.sz = a.sz;        <span class="hljs-keyword">if</span> (a.mn &gt; b.mn) c.mn = b.mn, c.sz = b.sz;        <span class="hljs-keyword">if</span> (a.mn == b.mn) c.mn = a.mn, c.sz = a.sz + b.sz;        <span class="hljs-keyword">return</span> c;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        <span class="hljs-keyword">if</span> (t[u].tag) {            t[ls].<span class="hljs-built_in">ladd</span>(t[u].tag);            t[rs].<span class="hljs-built_in">ladd</span>(t[u].tag);            t[u].tag = <span class="hljs-number">0</span>;        }    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (l == r) {t[u] = (Node){y, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>}; <span class="hljs-keyword">return</span>;}        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf</span>(ls, l, mid, x, y);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">mdf</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {t[u].<span class="hljs-built_in">ladd</span>(z); <span class="hljs-keyword">return</span>;}        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);        t[u] = <span class="hljs-built_in">merge</span>(t[u], t[ls], t[rs]);    }    <span class="hljs-function">Node <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u];        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>((Node){<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, <span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));    }    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> ls</span>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> rs</span>}<span class="hljs-type">int</span> lx;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lk</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> x)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[x].<span class="hljs-built_in">size</span>(); i++) {        <span class="hljs-type">int</span> v = G[x][i];        <span class="hljs-keyword">if</span> (v &lt; l || v &gt; x) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (!LCT::<span class="hljs-built_in">link</span>(x, v)) {            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {                <span class="hljs-keyword">if</span> (G[x][j] &lt; l || G[x][j] &gt; x) <span class="hljs-keyword">continue</span>;                LCT::<span class="hljs-built_in">cut</span>(x, G[x][j]);            }            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        }        lx++;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;}<span class="hljs-type">int</span> dt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ct</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> r)</span> </span>{    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : G[x]) {        <span class="hljs-keyword">if</span> (v &gt; r || v &lt; x) <span class="hljs-keyword">continue</span>;        LCT::<span class="hljs-built_in">cut</span>(x, v);        <span class="hljs-comment">// printf("? %d %d %d\n", x, v, r);</span>        _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, v, r, <span class="hljs-number">1</span>);    }}<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> r = <span class="hljs-number">2</span>;    _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l &lt; nm; l++) {        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>        <span class="hljs-keyword">while</span> (r &lt;= nm) {            lx = <span class="hljs-number">0</span>;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">lk</span>(l, r)) <span class="hljs-keyword">break</span>;            <span class="hljs-comment">// printf("%d %d %d\n", r, qry2(1, 1, nm, r - 1), lx);</span>            _Smt::<span class="hljs-built_in">mdf</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r, _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, r - <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>).mn + <span class="hljs-number">1</span> - lx);            r++;        }        ans += _Smt::<span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l, r - <span class="hljs-number">1</span>).sz;        <span class="hljs-comment">// printf("%d %d %d %d\n", l, r - 1, _Smt::qry(1, 1, nm, l, r - 1).mn, _Smt::qry(1, 1, nm, l, r - 1).sz);</span>        <span class="hljs-comment">// for (int i = l; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>        <span class="hljs-built_in">ct</span>(l, r - <span class="hljs-number">1</span>); _Smt::<span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, nm, l + <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);        <span class="hljs-comment">// puts("?");</span>        <span class="hljs-comment">// for (int i = l + 1; i &lt; r; i++) printf("    %d %d\n", i, _Smt::qry(1, 1, nm, i, i).mn);</span>        <span class="hljs-comment">// printf("! %d %d %d %d\n", l, r - 1, qry(1, 1, nm, l, r - 1).mn, qry(1, 1, nm, l, r - 1).sz);</span>    }    ans++;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;n, &amp;m); nm = n * m;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a[i][j]);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i - <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">1</span>) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j - <span class="hljs-number">1</span>]);        <span class="hljs-keyword">if</span> (i &lt; n) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i + <span class="hljs-number">1</span>][j]);        <span class="hljs-keyword">if</span> (j &lt; m) G[a[i][j]].<span class="hljs-built_in">pb</span>(a[i][j + <span class="hljs-number">1</span>]);    }    <span class="hljs-built_in">solve</span>();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/CF1109F&quot;&gt;$\text{link}$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先考虑计算每个左端点对应的合法右端点的个数，可以发现随着 $l$ 的增大，使得 $[l,r]$ 不存在环的最大的 $r$</summary>
      
    
    
    
    <category term="题解" scheme="https://klii0314.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="https://klii0314.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="LCT" scheme="https://klii0314.github.io/tags/LCT/"/>
    
    <category term="Two Pointers" scheme="https://klii0314.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>CF232E Quick Tortoise</title>
    <link href="https://klii0314.github.io/2022/03/15/CF232E-Quick-Tortoise/"/>
    <id>https://klii0314.github.io/2022/03/15/CF232E-Quick-Tortoise/</id>
    <published>2022-03-15T07:34:05.000Z</published>
    <updated>2022-03-15T07:41:37.792Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF232E">$\text{link}$</a></p><p>先将询问离线下来分治，设当前分治区间为 $[l,r]$ , $mid = (l + r) &gt;&gt; 1$，考虑处理左上角到右下角的询问，剩下的分到左右两边。</p><p>由于路径必然经过 $y=mid$ 这条直线，考虑记 $g1(i,j,k) = 1/0$ 表示 $(i,j)$ 能否走到 $(k,mid)$， $g2(i,j,k) = 1/0$ 表示 $(k,mid)$ 能否走到 $(i,j)$，</p><p>然后转移用 $bitset$ 优化一下就可以做到 $\mathrm{O(\dfrac {n^2m\log m}{\omega} + \dfrac {qn}{\omega})}$ 。</p><p>实现的时候 $(i,j)$ 的意义是反过来的（（</p><p>$\text{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> f ? -x : x;}<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">500</span> + <span class="hljs-number">5</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxq = <span class="hljs-number">6e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, m, ans[maxq]; <span class="hljs-type">char</span> c[maxn][maxn];<span class="hljs-keyword">struct</span> <span class="hljs-title class_">_ques</span> {    <span class="hljs-type">int</span> xl, yl, xr, yr, id;} qr[maxq], q0[maxq], q1[maxq];<span class="hljs-type">int</span> ck[maxn];bitset&lt;maxn&gt; g1[maxn][maxn], g2[maxn][maxn];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>{    <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (l == r) {        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) ck[i] = ck[i - <span class="hljs-number">1</span>] + (c[i][r] == <span class="hljs-string">'#'</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)        <span class="hljs-keyword">if</span> (ck[qr[i].xr] == ck[qr[i].xl - <span class="hljs-number">1</span>]) ans[qr[i].id] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span>;    }    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>, c0 = <span class="hljs-number">0</span>, c1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt;= r; j++)    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) g1[j][i].<span class="hljs-built_in">reset</span>(), g2[j][i].<span class="hljs-built_in">reset</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {            <span class="hljs-keyword">if</span> (i) g2[mid][i] |= g2[mid][i - <span class="hljs-number">1</span>];            g2[mid][i].<span class="hljs-built_in">set</span>(i);        }        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &lt;= r; j++) {            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (i) g2[j][i] |= g2[j][i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (j &gt; mid) g2[j][i] |= g2[j - <span class="hljs-number">1</span>][i];        }    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) {        <span class="hljs-keyword">if</span> (c[i][mid] == <span class="hljs-string">'.'</span>) {            <span class="hljs-keyword">if</span> (i &lt; n) g1[mid][i] |= g1[mid][i + <span class="hljs-number">1</span>];            g1[mid][i].<span class="hljs-built_in">set</span>(i);        }        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = mid; j &gt;= l; j--) {            <span class="hljs-keyword">if</span> (c[i][j] == <span class="hljs-string">'#'</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (i &lt; n) g1[j][i] |= g1[j][i + <span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (j &lt; mid) g1[j][i] |= g1[j + <span class="hljs-number">1</span>][i];        }    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L; i &lt;= R; i++)    <span class="hljs-keyword">if</span> (qr[i].yr &lt;= mid) q0[++c0] = qr[i];    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (qr[i].yl &gt; mid) q1[++c1] = qr[i];    <span class="hljs-keyword">else</span> {        <span class="hljs-comment">// printf("%d %d %d\n", qr[i].id, g1[qr[i].yl][qr[i].xl].count(), g2[qr[i].yr][qr[i].xr].count());</span>        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g1[qr[i].yl][qr[i].xl][j] ? 1 : 0); puts("");</span>        <span class="hljs-comment">// for (int j = 1; j &lt;= n; j++) printf("%d ", g2[qr[i].yr][qr[i].xr][j] ? 1 : 0); puts("");</span>        <span class="hljs-keyword">if</span> ((g1[qr[i].yl][qr[i].xl] &amp; g2[qr[i].yr][qr[i].xr]).<span class="hljs-built_in">count</span>()) ans[qr[i].id] = <span class="hljs-number">1</span>;    }    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c0; i++) qr[L + i - <span class="hljs-number">1</span>] = q0[i];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= c1; i++) qr[R - i + <span class="hljs-number">1</span>] = q1[i];    <span class="hljs-built_in">solve</span>(l, mid, L, L + c0 - <span class="hljs-number">1</span>);    <span class="hljs-built_in">solve</span>(mid + <span class="hljs-number">1</span>, r, R - c1 + <span class="hljs-number">1</span>, R);}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, c[i] + <span class="hljs-number">1</span>);    <span class="hljs-type">int</span> q = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) {        <span class="hljs-type">int</span> x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();        qr[i].xl = x; qr[i].yl = y;        x = <span class="hljs-built_in">read</span>(), y = <span class="hljs-built_in">read</span>();        qr[i].xr = x; qr[i].yr = y;        qr[i].id = i;    }    <span class="hljs-built_in">solve</span>(<span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, q);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) <span class="hljs-built_in">puts</span>(ans[i] ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/CF232E&quot;&gt;$\text{link}$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先将询问离线下来分治，设当前分治区间为 $[l,r]$ , $mid = (l + r) &amp;gt;&amp;gt; 1$，考虑处理左</summary>
      
    
    
    
    <category term="题解" scheme="https://klii0314.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="分治" scheme="https://klii0314.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="bitset" scheme="https://klii0314.github.io/tags/bitset/"/>
    
  </entry>
  
  <entry>
    <title>「雅礼集训 2018 Day7」A</title>
    <link href="https://klii0314.github.io/2022/03/15/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day7%E3%80%8DA/"/>
    <id>https://klii0314.github.io/2022/03/15/%E3%80%8C%E9%9B%85%E7%A4%BC%E9%9B%86%E8%AE%AD-2018-Day7%E3%80%8DA/</id>
    <published>2022-03-15T00:43:45.000Z</published>
    <updated>2022-03-15T02:17:13.567Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://loj.ac/p/6507">$\text{link}$</a></p><p>用线段树维护 $\text{And,Or,Min}$ 值，对于操作：</p><ul><li><p>$\text{And x}$，设当前点为 $u$，区间值分别为 $ta(u),to(u),tm(u)$：</p><ul><li><p>若 $x \And to(u) = to(u)$ ,则该操作对当前区间 $[l(u),r(u)]$ 的值无效；</p></li><li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p></li><li><p>否则直接暴力递归下去。</p></li></ul></li><li><p>$\text{Or x}$，类似的有：</p><ul><li><p>若 $ta(u) \And x = x$ ,则该操作对当前区间无效；</p></li><li><p>若 $to(u) \And x = ta(u) \And x$ ,则该操作对当前区间的每个数影响都是一样的，可以打懒标记维护；</p></li><li><p>否则直接暴力递归下去。</p></li></ul></li></ul><p>分析一下时间复杂度：每次暴力递归下去都会使得当前区间内所有数的某一位相同，每个区间不同位的总数为 $\mathrm{O(n\log n\log 值域)}$，时间复杂度即为 $\mathrm{O(n\log n\log 值域)}$ 。</p><p>$\text{Code:}$</p><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span>; <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c)) f |= c == <span class="hljs-string">'-'</span>, c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(c)) x = x * <span class="hljs-number">10</span> + (c ^ <span class="hljs-number">48</span>), c = <span class="hljs-built_in">getchar</span>();    <span class="hljs-keyword">return</span> f ? -x : x;}<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<span class="hljs-type">int</span> n, q, a[maxn];<span class="hljs-keyword">namespace</span> _Smt {    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> {        <span class="hljs-type">int</span> a, o, m, tg1, tg2;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">aladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a &amp;= x; o &amp;= x; m &amp;= x; tg1 = ~tg1 ? tg1 &amp; x : x; tg2 &amp;= x;}        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oladd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>{a |= x; o |= x; m |= x; tg2 |= x; tg1 = ~tg1 ? tg1 ^ (tg1 &amp; x) : tg1;}    } t[maxn &lt;&lt; <span class="hljs-number">2</span>];    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ls u &lt;&lt; 1</span>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rs u &lt;&lt; 1 | 1</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        t[u].a = t[ls].a &amp; t[rs].a;        t[u].o = t[ls].o | t[rs].o;        t[u].m = <span class="hljs-built_in">min</span>(t[ls].m, t[rs].m);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pd</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>{        <span class="hljs-keyword">if</span> (~t[u].tg1) t[ls].<span class="hljs-built_in">aladd</span>(t[u].tg1), t[rs].<span class="hljs-built_in">aladd</span>(t[u].tg1);        <span class="hljs-keyword">if</span> (t[u].tg2) t[ls].<span class="hljs-built_in">oladd</span>(t[u].tg2), t[rs].<span class="hljs-built_in">oladd</span>(t[u].tg2);        t[u].tg1 = <span class="hljs-number">-1</span>; t[u].tg2 = <span class="hljs-number">0</span>;    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>{        t[u].tg1 = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span> (l == r) {            t[u].a = t[u].o = t[u].m = a[l];            <span class="hljs-keyword">return</span>;        }        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">build</span>(ls, l, mid);        <span class="hljs-built_in">build</span>(rs, mid + <span class="hljs-number">1</span>, r);        <span class="hljs-built_in">up</span>(u);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{        <span class="hljs-keyword">if</span> ((z &amp; t[u].o) == t[u].o) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {            <span class="hljs-keyword">if</span> (l == r) {                t[u].<span class="hljs-built_in">aladd</span>(z);                <span class="hljs-keyword">return</span>;            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {                t[u].<span class="hljs-built_in">aladd</span>(z);                <span class="hljs-keyword">return</span>;            }        }        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf1</span>(ls, l, mid, x, y, z);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf1</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);        <span class="hljs-built_in">up</span>(u);    }    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mdf2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>{        <span class="hljs-keyword">if</span> ((t[u].a &amp; z) == z) <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (l ^ r) <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) {            <span class="hljs-keyword">if</span> (l == r) {                t[u].<span class="hljs-built_in">oladd</span>(z);                <span class="hljs-keyword">return</span>;            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t[u].o &amp; z) == (t[u].a &amp; z)) {                t[u].<span class="hljs-built_in">oladd</span>(z);                <span class="hljs-keyword">return</span>;            }        }        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">mdf2</span>(ls, l, mid, x, y, z);        <span class="hljs-keyword">if</span> (y &gt; mid) <span class="hljs-built_in">mdf2</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y, z);        <span class="hljs-built_in">up</span>(u);    }    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>{        <span class="hljs-keyword">if</span> (x &lt;= l &amp;&amp; r &lt;= y) <span class="hljs-keyword">return</span> t[u].m;        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-built_in">pd</span>(u);        <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y);        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(ls, l, mid, x, y);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">qry</span>(ls, l, mid, x, y), <span class="hljs-built_in">qry</span>(rs, mid + <span class="hljs-number">1</span>, r, x, y));    }}<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> _Smt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>();    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">while</span> (q--) {        <span class="hljs-type">int</span> opt, l, r, x;        opt = <span class="hljs-built_in">read</span>(); l = <span class="hljs-built_in">read</span>(); r = <span class="hljs-built_in">read</span>();        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>) {            x = <span class="hljs-built_in">read</span>();            <span class="hljs-built_in">mdf1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);        }        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) {            x = <span class="hljs-built_in">read</span>();            <span class="hljs-built_in">mdf2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, x);        }        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">3</span>) {            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r));        }    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://loj.ac/p/6507&quot;&gt;$\text{link}$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用线段树维护 $\text{And,Or,Min}$ 值，对于操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\text{And x}$，设当前点为 $u$，区间值分</summary>
      
    
    
    
    <category term="题解" scheme="https://klii0314.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="线段树" scheme="https://klii0314.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="势能分析" scheme="https://klii0314.github.io/tags/%E5%8A%BF%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>联合省选2022前的记录</title>
    <link href="https://klii0314.github.io/2022/03/11/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892022%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>https://klii0314.github.io/2022/03/11/%E8%81%94%E5%90%88%E7%9C%81%E9%80%892022%E5%89%8D%E7%9A%84%E8%AE%B0%E5%BD%95/</id>
    <published>2022-03-11T14:01:44.000Z</published>
    <updated>2022-03-16T01:34:36.496Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2d80ce7d79858ffa06e1bec2fe58d934c1428df69ae73a2af52f9f24ad281868">cd67862bdd141bb2aa1c78ab2fd399f6025480595d1e8c8c68d7bb7df6fc241012de68bb08422b6f66aa40e30ff3ba9897f4891827ea4427b65670833740266d8d21bb3e199773503e6edc7740dc576743fb6d95d69b06fbcc02676aea6d19c5ac639d10dfd106bb9dc39850099af7ff65d616d0f01194b07328c65d30bd35f1d4ef0d847d78998ec34cc7bde7144dbb6ec7807c29301eec9a59e20d98c7b49e2b3305ca621c9fb133c006f3b23b17b05a78ff540ebfa2fd0fa42ac5b59e26efc9a4153b24fb14b5a475fe221f73c49e51b2722abf28548597639c30b80d6d29785675e123144650e6a53cd47553b94846a1e256dda31713ef698f9c83be6e4ce31159d0a4e5a87ae12f94c3e3658c401aa33640b1c004c8fe61d1717966e667b6dc7ae3134fa6d6a3225e18ab920212836639db9b6f5047b38f09e09f1202596358b5a7d703c525f385b2598c2a3f8094ed396a7ef0b52ed9fda5393eaaeef0a5d5719c2db14b243bf12bec10fffcec50e9a8e201e073ffee8f228ad9d173cb19a6eee0c6818823483c4c841fccd76545763ba55ca7bf802ae8145dd4d12c4a126137ae710c4ef0b0d73aefe06fbc947a8a893ef5f10607856dfe195e8c8eddaabfc256466c8938f8f5341e98037a67ac34cc5b2896f5f3a5c0ac92b8d95806202d94982be671aac05786e410bf31aca34938968b194811a91424a17db4b4f776436a43dc1d16db45bd4e9fc1734cf223d6057a2ad06e43329ae79df55d10f01294e67de7c7af95b21e44139f3ab3f221ea6965cf89c48fbfa3e1be1e27181f4d9079d8a290b6e100afa920dba627c73ab0d718ccb70870bb0d2169e4bfaf4baad5bb74f7cfe3978551bf5740be864161baf68682c47e0da3a6257921b4c0e5232ea23f1240a5e9b7eb9532d4e98e387e42f3e29271a948156a9fcb39471b093f9d9db5ccaf78d7921ca7f8a800ccbd08e2002753721700c823cb3b5994b70e62e63d0ed162efaf93a123bb1977d7f9d3b6cf337b17788dff9ef4c1322ea6758d99ab4a64b4e76aaf7cc25ffe1dbf28148328b30a88c6961d7dddf45c759c599d139182fd374856c9934ab0cb19c940b016d6e0b2812f2d9031a2c70adacbb7feb5f4bfd63809abe643ded41d7a82f7b0b6b683f3e2578320bc625a281dc0043ef54714e7807580df9981e5cc14c28f17a8dd399ae27618cafe854d20a42386222fc2d61a7b30e1236ffe7a3833c4af2c71e0979256d2ec085f3d5c5f37e4ef221666871ce57d72e688ce09d3ae446b41be33cc07041bbe0db1e070797660dddc6e06a5a07a85b750706eefa7c0b0f6252905d3d7f5f3d20d1b176e385d716ba074289a58301564e5dc0af204a32d95b6590c7b2b16aae3ea4b04d8cde401c9daae02e529f4993e5e6c394de6fe4bb8391429f77490e04ff40927f85edb5e8c9e9b762fa0cd920afd42fb484e442767dadec10ee3b577e345d55e0aaf66d1be0eaa9fea6d75cd0f303958e68ae1bf730fd96a678ee85cb8c369160bce2558c5066526f7427fc054b7cf6dd1b09edbb44086a8070b86280d6996f6a58a812a80c01361fddd719c26635093290dd244fa60c6637fba4f9210940eacc8b48f20554e1efe45bda855d6f27cc191cb025b8bb45cabe6cbe52ac0ac851f3d8abacb8c303fb7feb22f66520f2bf5a2365aa9185f9da844ea57b3a007ed65d91f02608b2a621933c7156d2b83ec87c36fb5fb1cf417d8a466bc4d87f25ee1a08144f46aeacc2f1c3dd4ec32453400bc948b347cfecd217a83eaecb36b4efbc3128eedfba89026218098462ae8e69b4885a20b54918d366ceb836d343973b272972e611466f0dadaf02cf796ad1993bdd105a43fcf41b6401cfa72d3f543a17133d0036c3f08f16db598b6edcafbea3730fde8fc80c731f3888fcf35065672ef344e7cb85cd11410497f9fbb2978fb6d01093987707e530262b382c60d89d43f283fddc7144870790fc7a89226401d3fa8435585ce1cda78592422611bdc26424b3c3bd02d960d0aeb5bcb781cc52a1bb644b3ca2b3c998333244c2ac2969486a6e42b1419a545ce542b40d50ae2281849b5ed67a8460c6754a3b89f4579bb1af614a5c806301401a56079db61cfb3b6a1e741a113c0b2d91782ec1bea4f374f0f4a7c6aaea8b3a03a734c8516dff03d15c114f25e2f6104da41b83bc9b351fe6408ef2a2085998c9e577ed1974fa0152dce8032191ced18714071d580579cfe59dda55616f17706fed51ede5141b12a008eb61545901687a56d725b732d5e57541b1b822923b796b403bd504e07861d89bc63d620d7c0b6dfdccac39537537b61abb0ee16b76678f6aac4b21e402c4105c2398535de9e0194226f6be8b8b76d88a6e543d4c583998ab1dd30fb20c33d820163ca9d44c5e81c7b105672cbd19e7539dffa0b9268767171e748902ba070f2d010ff61a1377a86d9d13f4cfc821b8909c2d5bef12d7e7e49f3b741724b5e07c51af7db02274f6a4a4fc48d21a62727e080e972b3e4493a7cde65fd74a466027b7554bd19a79fbc1de4c72c7a52ed1e84495e57eb03ffed0a2af20f62fff401e6797771dc903ab431b1299f3c8b9cb7d46b7eb7ca5144d576fb6c45098b5b438850dc4cfc32f6027a72c9f066bd55fd0b9e4cbdea75641e4815a45f94b4cae2c3b32eb280353c17c8f4d6c3e637e50085fa3893cebb62166b9a009f29a7de2431ef05cb92e619f4b2b656c51385d38b755b8c54ab71b7bc27097310fd6bf0e98e72520c14da84bcd8a0ff9c24a8ad64785bad9c82c97ffa2931baa91d7fd558056d7130282bea41c3b15fed9a9b40d6f2ba5521a3c0d1cc042e2eb86d0fb8ebf4411912df5fe92037a9b055f5c567bd99214f924846633bf134db5c5696b9517bfd8844523b738ee9511d73a1d08413c8c2225766156df52134864dab3d1616ddd90dbe6d69d6574caab147fcd5d4cbfb207937a2dcb4eb09eacf1704c5f200859c451ef74d17faea78574b960f3dea125f30bb8aa9d59462614165767e0cf9636894148539bd0c2fbfc4d692fc6fa12cff7715cfeca4eeeaf7fa41618be9a3944ec276bad93c2e41136b0063e0d66ca8c70e859a721e91a4471a513420ed0b2f5e7256e91626012edaa49cb30c06f7e588170c3e66662e63dc55cc7fe5a23cf7779df309386b4ff46129fa7d9552209d84cd43ab29e76d335a58f8a1666806f32d3f3035002e8a74f5d280a8ce9614cf474d31e449a3458bc7fb335b276c99944d8ae1135ddec22c604bcbd6059ca71769add4e636a712303aeb53f275c6ffdb454dcd9d95aae0150b5820b3c01eff926939c4534a63816598aa5b127f8b93769842ff8205653c68d661b9db7b97374017bc7face85ec4ecd2887c8c3f84f66eb64dc0489b45a5178bd6e2afa794ebeb9a24d6e6dee0f23bd5f3d0a2626b2c1e668d886cfa89aa5a50535396c31d83fcb44bedd13fb2de50423e73c1bf1ca3861a0c378e9eeedadbe2ce913a435e3b6a8af58c97683f58731b599ac8c650aeb560bdb2cea14cd20aa47964d55a5db8a3327b205a32bc6f5d2142b7c95d475bc3d1f294f5f36cdf1d6587677cca7de4f891c25b60bf4f20d61e48d01b600659bc5947ad6208e6ef2ab09a7a5f06194f1f90a4077a40b60b79e7f0698d8aa168fccbf01a5404bcde57622d8a2e9c0f77034c3ac7cd2a506428b8c3e190e91443f6cece0e9efeb7fec24c034743cf51b71ecf931fedfe13d66b847f3fa9db2f4fe6e8ac594f8b392d6733c11d3375ff3350eec91cbb5a58b9c54bcd87c1cb849453887f977839cf97943f50c127d71acf82345d71fb97b2fa120824c06ae432685727a4c9a3eff4fda6f19d6653b530120ce5be3f56bab6a8621ea5764ef74acf07f088529a8e51c779f86912ff5c499305116c901fb224feb089d5e29180a683a13693af79f193d3e41b4321eb8b4391d2d510</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="记录" scheme="https://klii0314.github.io/categories/%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
